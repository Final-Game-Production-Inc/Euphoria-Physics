// 
// phsolver/updatecontactsmovandmov.cpp 
// 
// Copyright (C) 1999-2011 Rockstar Games.  All Rights Reserved. 
// 

#include "forcesolver.h"

#include "phcore/phmath.h"
#include "phcore/constants.h"
#include "physics/collider.h"
#include "physics/contact.h"
#include "physics/manifold.h"

SOLVER_OPTIMISATIONS()

namespace rage {

#if ACCUMULATION_SOLVER_MATH == 0

void UpdateContactsMovAndMov(phManifold& manifold, const phForceSolverGlobals& SPU_ONLY(globals))
{
	phCollider* colliderA = manifold.GetColliderA();
	phCollider* colliderB = manifold.GetColliderB();

	Mat33V mA(*(Mat33V*)&colliderA->GetMatrix());
	Mat33V mB(*(Mat33V*)&colliderB->GetMatrix());

	float negMassSum = -(colliderA->GetSolverInvMass() * manifold.GetMassInvScaleA())-(colliderB->GetSolverInvMass() * manifold.GetMassInvScaleB());
	float massInvA = Selectf(negMassSum, colliderA->GetInvMass(), colliderA->GetSolverInvMass());
	float massInvB = Selectf(negMassSum, colliderB->GetInvMass(), colliderB->GetSolverInvMass());
	manifold.SetMassInvA(massInvA * manifold.GetMassInvScaleA());
	manifold.SetMassInvB(massInvB * manifold.GetMassInvScaleB());

	Vec3V inertiaA=colliderA->GetSolverInvAngInertia();
	Vec3V inertiaB=colliderB->GetSolverInvAngInertia();

#if !__SPU
	phMathInertia::GetInverseInertiaMatrix(mA,RCC_VECTOR3(inertiaA),manifold.GetInertiaInvA());
	phMathInertia::GetInverseInertiaMatrix(mB,RCC_VECTOR3(inertiaB),manifold.GetInertiaInvB());
#else
	globals.GetInverseInertiaMatrix(mA,RCC_VECTOR3(inertiaA),manifold.GetInertiaInvA());
	globals.GetInverseInertiaMatrix(mB,RCC_VECTOR3(inertiaB),manifold.GetInertiaInvB());
#endif
	Vec3V massInvScaleAV = Vec3VFromF32(manifold.GetMassInvScaleA());
	Vec3V massInvScaleBV = Vec3VFromF32(manifold.GetMassInvScaleB());
	Scale(manifold.GetInertiaInvA(), manifold.GetInertiaInvA(), massInvScaleAV);
	Scale(manifold.GetInertiaInvB(), manifold.GetInertiaInvB(), massInvScaleBV);

#if USE_ELASTICITY_FOR_MOV_AND_MOV && FORCESOLVER_USE_NEW_BOUNCE_VELOCITY //Disabled for mov and mov for now because it causes problems otherwise
	// The 'incoming' velocities are the velocities that this object had before forces and impulses (including gravity) were applied for this frame and
	//   before any velocities are changed in response to collisions/constraints.  It is important that we use these values for determining our target,
	//   post-collision-response, velocity, because we don't want an object resting on a surface to bounce due to reflecting the effects of one frame's
	//   worth of gravitational acceleration.  (Strictly speaking it *would* be okay to reflect the portion of the velocity that accumulated before the
	//   collision actually occurred but that's a little extra calculation for probably no observable benefit.)
	const Vec3V incomingLinearVelocityA = colliderA->GetVelocityBeforeForce();
	const Vec3V incomingLinearVelocityB = colliderB->GetVelocityBeforeForce;
	const Vec3V incomingAngularVelocityA = colliderA->GetAngVelocityBeforeForce();
	const Vec3V incomingAngularVelocityB = colliderB->GetAngVelocityBeforeForce();
#endif

	Vec3V velocityA = colliderA->GetVelocity();
	Vec3V velocityB = colliderB->GetVelocity();
	Vec3V angVelA = colliderA->GetAngVelocity();
	Vec3V angVelB = colliderB->GetAngVelocity();

	for(int c=0;c<manifold.GetNumContacts();c++) {
		phContact& cp = manifold.GetContactPoint(c);
		if (Likely(cp.IsContactActive()))
		{
			//			cp.worldPoint[0] = rotate(stateA.fQ,cp.getLocalPointA());
			//			cp.worldPoint[1] = rotate(stateB.fQ,cp.getLocalPointB());

			////////////////////////////////////////////////////////////////////////////////////////////////////
			// Compute a matrix, K, that answers the question "if I apply an impulse (or force) to these two bodies at their respective locations
			//   and along the normal, what kind of local motion (change in velocity or acceleration) along that normal do I get as a result?".
			// The code below can be a little difficult to read, so here it is in more conventional mathematical notation:
			// K = 1/m0 + 1/m1 + [I0^-1(r1 x n) x n] . n + [I1^-1(r2 x n) x n] . n
			// As further explanation, the first two terms account for the motion that comes from the motion of the center of mass.
			// The third and fourth terms account for the part of the motion that comes as a result of the rotation of the two objects.
			// To see how this is the case, consider the term "[I0^-1(r1 x n) x n] . n".  Starting from the inside:
			// 1) r1 x n represents the amount of angular impulse (or torque) generated by a unit impulse (or force) exerted at a point r1.
			// 2) I0^-1(r1 x n) represents the angular motion (change in angular velocity or angular acceleration) that results from the above-mentioned
			//   angular impulse (or torque).
			// 3) [I0^-1(r1 x n) x n] represents the amount of linear motion (change in velocity or acceleration), at point r1, that results from the
			//   above mentioned angular impulse (or torque).
			// 4) Finally [I0^-1(r1 x n) x n] . n represents the amount of local linear motion that is along the normal.

#if USE_CENTRE_POINT_FOR_CONTACTS
			Vec3V localPos=cp.GetWorldPosA() + cp.GetWorldPosB();
			localPos*=ScalarV(V_HALF);
			Vec3V localPosA = localPos - colliderA->GetPosition();
			Vec3V localPosB = localPos - colliderB->GetPosition();
#else
			Vec3V localPosA = cp.GetWorldPosA() - colliderA->GetPosition();
			Vec3V localPosB = cp.GetWorldPosB() - colliderB->GetPosition();
#endif
			Mat33V scaleMatrix;
			Mat33VFromScale(scaleMatrix, Vec3VFromF32(manifold.GetMassInvA()) + Vec3VFromF32(manifold.GetMassInvB()));
			Mat33V crossA, crossB;
			CrossProduct(crossA, localPosA);
			CrossProduct(crossB, localPosB);
			Mat33V termA, termB;
			Multiply(termA, crossA, manifold.GetInertiaInvA());
			Multiply(termA, termA, crossA);
			Multiply(termB, crossB, manifold.GetInertiaInvB());
			Multiply(termB, termB, crossB);
			Mat33V K(scaleMatrix - termA - termB);
			//
			////////////////////////////////////////////////////////////////////////////////////////////////////

			cp.SetImpulseDen(InvertSafe(Dot(Multiply(K, cp.GetWorldNormal()),cp.GetWorldNormal()), ScalarV(V_ZERO)));
			cp.SetAccumPush(ScalarV(V_ZERO));

#if 1
			Vec3V localVelocityA = velocityA + Cross(angVelA,localPosA);
			Vec3V localVelocityB = velocityB + Cross(angVelB,localPosB);
#else
			Vec3V localVelocityA = incomingLinearVelocityA + Cross(incomingAngularVelocityA,localPosA);
			Vec3V localVelocityB = incomingLinearVelocityB + Cross(incomingAngularVelocityB,localPosB);
#endif

			Vec3V relativeVelocity = localVelocityA-localVelocityB - cp.GetTargetRelVelocity();
			//				const Vec3V oldTangent = cp.GetTangent();
			Vec3V newTangent = NormalizeSafe(Cross(cp.GetWorldNormal(),Cross(cp.GetWorldNormal(),relativeVelocity)), Vec3V(V_ZERO));
			cp.SetTangent(newTangent);
			cp.SetFrictionDen(InvertSafe(Dot(Multiply(K, newTangent), newTangent), ScalarV(V_ZERO)));

#if USE_ELASTICITY_FOR_MOV_AND_MOV //Disabled for mov and mov for now because it causes problems otherwise
			if (globals.calculateBounceAndTangent.Getb())
			{
#if !FORCESOLVER_USE_NEW_BOUNCE_VELOCITY
				ScalarV normalVelocity = Dot(relativeVelocity, cp.GetWorldNormal());
				normalVelocity = SelectFT(normalVelocity > globals.minBounce, normalVelocity, ScalarV(V_ZERO));
				Vec3V bounceVelocity = Scale(cp.GetWorldNormal(), normalVelocity * cp.GetElasticityV());
				cp.SetTargetRelVelocity(cp.GetTargetRelVelocity() + bounceVelocity);
#else
				const Vec3V incomingLocalVelocityA = incomingLinearVelocityA + Cross(incomingAngularVelocityA, localPosA);
				const Vec3V incomingLocalVelocityB = incomingLinearVelocityB + Cross(incomingAngularVelocityB, localPosB);
				const Vec3V incomingRelativeVelocity = incomingLocalVelocityA - incomingLocalVelocityB - cp.GetTargetRelVelocity();
				const ScalarV normalVelocity = Dot(incomingRelativeVelocity, cp.GetWorldNormal());
				const Vec3V bounceVelocity = Scale(cp.GetWorldNormal(), normalVelocity * cp.GetElasticityV());
				cp.SetTargetRelVelocity(cp.GetTargetRelVelocity() + bounceVelocity);
#endif
			}
#endif
		}
	}
}

#else // ACCUMULATION_SOLVER_MATH == 0

void UpdateContactsMovAndMov(phManifold& manifold, const phForceSolverGlobals& globals)
{
	phCollider* colliderA = manifold.GetColliderA();
	phCollider* colliderB = manifold.GetColliderB();

	Mat33V mA(*(Mat33V*)&colliderA->GetMatrix());
	Mat33V mB(*(Mat33V*)&colliderB->GetMatrix());

	manifold.massInv[0] = colliderA->GetSolverInvMass() * manifold.GetMassInvScaleA();
	manifold.massInv[1] = colliderB->GetSolverInvMass() * manifold.GetMassInvScaleB();
#if !__SPU
	phMathInertia::GetInverseInertiaMatrix(mA,colliderA->GetSolverInvAngInertia(),manifold.inertiaInv[0]);
	phMathInertia::GetInverseInertiaMatrix(mB,colliderB->GetSolverInvAngInertia(),manifold.inertiaInv[1]);
#else
	globals.GetInverseInertiaMatrix(mA,colliderA->GetSolverInvAngInertia(),manifold.inertiaInv[0]);
	globals.GetInverseInertiaMatrix(mB,colliderB->GetSolverInvAngInertia(),manifold.inertiaInv[1]);
#endif
	Vec3V massInvScaleAV = Vec3VFromF32(manifold.GetMassInvScaleA());
	Vec3V massInvScaleBV = Vec3VFromF32(manifold.GetMassInvScaleB());
	Scale(manifold.inertiaInv[0], manifold.inertiaInv[0], massInvScaleAV);
	Scale(manifold.inertiaInv[1], manifold.inertiaInv[1], massInvScaleBV);

	Vec3V velocityA = colliderA->GetVelocity();
	Vec3V velocityB = colliderB->GetVelocity();
	Vec3V angVelA = colliderA->GetAngVelocity();
	Vec3V angVelB = colliderB->GetAngVelocity();

	for(int c=0;c<manifold.GetNumContacts();c++) {
		phContact& cp = manifold.GetContactPoint(c);
		if (Likely(cp.IsContactActive()))
		{
#if USE_CENTRE_POINT_FOR_CONTACTS
			Vec3V localPos=cp.GetWorldPosA() + cp.GetWorldPosB();
			localPos*=ScalarV(V_HALF);
			Vec3V localPosA = localPos - colliderA->GetPosition();
			Vec3V localPosB = localPos - colliderB->GetPosition();
#else
			Vec3V localPosA = cp.GetWorldPosA() - colliderA->GetPosition();
			Vec3V localPosB = cp.GetWorldPosB() - colliderB->GetPosition();
#endif

			Mat33V constraintAxis;
			MakeOrthonormals(cp.GetWorldNormal(), constraintAxis.GetCol1Ref(), constraintAxis.GetCol2Ref());
			constraintAxis.SetCol0(cp.GetWorldNormal());

			Vec3V targetConstraintVelocity(V_ZERO);

			Vec3V bounceVelocityA;
			colliderA->GetLocalVelocity(cp.GetWorldPosA().GetIntrin128(), bounceVelocityA, cp.GetComponentA());
			bounceVelocityA = Scale(bounceVelocityA, cp.GetElasticityV());
			targetConstraintVelocity += bounceVelocityA;

			Vec3V bounceVelocityB;
			colliderA->GetLocalVelocity(cp.GetWorldPosB().GetIntrin128(), bounceVelocityB, cp.GetComponentB());
			bounceVelocityB = Scale(bounceVelocityB, cp.GetElasticityV());
			targetConstraintVelocity -= bounceVelocityB;

			// Find the effective depth to modify the effective relative velocity along the contact normal.
			ScalarV normalRelVel = Dot(targetConstraintVelocity, constraintAxis.GetCol0());

			if(!cp.IsConstraint())
			{
				// Allow some penetration, down to GetAllowedPenetration(). This makes the target velocity for the solver not zero, but just enough
				// to reach the allowed penetration at the end of the frame, if the allowed penetration is not already exceeded.
				ScalarV adjustmentDepth = Max(ScalarV(V_ZERO), globals.allowedPenetration-cp.GetDepthV());
				normalRelVel += adjustmentDepth * globals.invTimeStep;
			}

			Vec3V rv( normalRelVel,Dot(targetConstraintVelocity, constraintAxis.GetCol1()),Dot(targetConstraintVelocity, constraintAxis.GetCol2()));

			cp.SetTargetRelVelocity(UnTransformOrtho(constraintAxis, cp.GetTargetRelVelocity()) - rv);

			// Set the transposed coordinate system.
			Mat33V contactLocal;
			Transpose( contactLocal, constraintAxis );

			Mat33V cTwA;
			cTwA.SetCol0( Cross( localPosA, constraintAxis.GetCol0() ) );
			cTwA.SetCol1( Cross( localPosA, constraintAxis.GetCol1() ) );
			cTwA.SetCol2( Cross( localPosA, constraintAxis.GetCol2() ) );
			Transpose( cTwA, cTwA );

			Mat33V cTwB;
			cTwB.SetCol0( Cross( localPosB, constraintAxis.GetCol0() ) );
			cTwB.SetCol1( Cross( localPosB, constraintAxis.GetCol1() ) );
			cTwB.SetCol2( Cross( localPosB, constraintAxis.GetCol2() ) );
			Transpose( cTwB, cTwB );

			// Set the linear part of the Jacobian for the rigid body to the translational part of the inverse mass matrix.
			Mat33V scaleMatrixA;
			Mat33VFromScale(scaleMatrixA, Vec3VFromF32(manifold.massInv[0]));

			// Multiply translational part of the inverse mass matrix by the local coordinates.
			Multiply(scaleMatrixA,contactLocal,scaleMatrixA);

			// Multiply the linear part of the Jacobian by the coordinate system transpose, and set the output.
			Mat33V linearJacobianA;
			Multiply(linearJacobianA, scaleMatrixA, constraintAxis);

			Mat33V angularJacobianA;
			Multiply(angularJacobianA,cTwA,manifold.inertiaInv[0]);

			// Set the linear part of the Jacobian for the rigid body to the translational part of the inverse mass matrix.
			Mat33V scaleMatrixB;
			Mat33VFromScale(scaleMatrixB, Vec3VFromF32(manifold.massInv[1]));

			// Multiply translational part of the inverse mass matrix by the local coordinates.
			Multiply(scaleMatrixB,contactLocal,scaleMatrixB);

			// Multiply the linear part of the Jacobian by the coordinate system transpose, and set the output.
			Mat33V linearJacobianB;
			Multiply(linearJacobianB, scaleMatrixB, constraintAxis);

			Mat33V angularJacobianB;
			Multiply(angularJacobianB,cTwB,manifold.inertiaInv[1]);

			Mat33V JJt;
			Mat33V Jt;
			Transpose( Jt, cTwA );
			Multiply( JJt, angularJacobianA, Jt ); // concetentation Jw0*Jt
			Mat33V dinv;
			Add( dinv, JJt, linearJacobianA );

			Transpose( Jt, cTwB );
			Multiply( JJt, angularJacobianB, Jt );  // concetentation Jw1*Jt

			Add( dinv, dinv, JJt );
			Add( dinv, dinv, linearJacobianB );

			cp.SetFrictionPlaneProjection(InvScale(dinv.GetCol0(), Vec3V(SplatX(dinv.GetCol0())) ));

			VALIDATE_PHYSICS_ASSERTF(dinv.GetM00f()+dinv.GetM11f()+dinv.GetM22f()>=0.0f,"Contact force solver inverting a bad matrix, diagonals = %f, %f, %f",dinv.GetM00f(),dinv.GetM11f(),dinv.GetM22f());
			LCPSolver::InvertPositiveDefinite( (float*)(&dinv), 4 );
			cp.SetDinv(dinv);

			cp.SetPreviousPush(Vec3V(V_ZERO));
		}
	}
}

#endif // ACCUMULATION_SOLVER_MATH == 0

} // namespace rage
