//
// crskeleton/skeletondata.h
//
// Copyright (C) 1999-2012 Rockstar Games.  All Rights Reserved.
//

#ifndef CRSKELETON_SKELETONDATA_H
#define CRSKELETON_SKELETONDATA_H

#include "bonedata.h"

#include "atl/map.h"
#include "paging/base.h"

namespace rage
{

class crProperties;

////////////////////////////////////////////////////////////////////////////////

// PURPOSE: crSkeletonData holds data that applies to all crSkeleton's of a particular
// type.  Most of its actual data is in the crBoneData it owns, and in the
// structure they describe.
class crSkeletonData: public pgBase
{
public:
	// PURPOSE: Default constructor
	crSkeletonData();

	// PURPOSE: Resource constructor
	crSkeletonData(datResource&);

	// PURPOSE: Destructor
	~crSkeletonData();

	DECLARE_PLACE(crSkeletonData);

#if __DECLARESTRUCT
	void DeclareStruct(class datTypeStruct&);
#endif // __DECLARESTRUCT

	static const int RORC_VERSION = 10;

#if CR_DEV
	// PURPOSE: Private copy constructor, not implemented and should never be used (except for dev data - needed
	// to be able to store skeleton data after the owning entity has streamed out)
	crSkeletonData(const crSkeletonData& skelData);

	// PURPOSE: Allocate and Load the skeleton data from a file.
	// PARAMS: filename - the input file from which to get the skeleton data.
	// RETURN: pointer of the crSkeletonData object, will return NULL if load failed.
	static crSkeletonData* AllocateAndLoad(const char* filename, int* outVersion=NULL);

	// PURPOSE: Load the skeleton data from a file
	// PARAMS: filename - the input file from which to get the skeleton data.
	// RETURN: true - load succeeded, false - load failed
	bool Load(const char *filename, int* outVersion=NULL);

	// PURPOSE: Save skeleton data as a .skel file
	// PARAMS: filename - name of .skel file to save
	// RETURNS: true - if save successful, false - save failed
	bool Save(const char* filename);
#endif // CR_DEV

	// PURPOSE: Increment reference count
	void AddRef() const;

	// PURPOSE: Decrement reference count
	// RETURNS: Number of remaining references
	// NOTES: Will deallocate and return 0 when internal counter reaches zero
	int Release() const;

	// PURPOSE: Returns number of bones in skeleton.
	// RETURNS: Number of bones.
	int GetNumBones() const;

	// PURPOSE: Returns bone data
	// PARAMS: Bone index (will assert if not in range)
	// RETURNS: Non const pointer to bone data, can't be NULL
	crBoneData* GetBoneData(int boneIdx);
	const crBoneData* GetBoneData(int boneIdx) const;

	// PURPOSE: Returns bones
	// RETURNS: Non const pointer to bone data, can't be NULL
	const crBoneData* GetBones() const;
	crBoneData* GetBones();

	// PURPOSE: Finds bone data, given a bone name.
	// PARAMS: name - bone name.
	// RETURNS: const pointer to bone data, will be NULL if failed to find bone name
	// NOTES: Even though bone names can technically be case sensitive
	// (although this will cause bone id hash collisions) this search is case insensitive
	const crBoneData *FindBoneData(const char *name) const;

	// PURPOSE: Get the number of DOFs that can be animated
	// RETURNS: Number of DOFs that can be animated (by freedom type, not by component)
	// NOTES: The number of DOFs that can be animated is different to the total number of DOFs.
	// Total DOFs count individual XYZ components of translate/rotate on each bone,
	// while for animating purposes this would only count once (i.e. a bone that can translate
	// in X and Y, and rotate in Z has a total DOF count of three, but an
	// animation DOF count of just two - as both rotation and translation can be animated).
	u32 GetNumAnimatableDofs(u32 dofFlags = crBoneData::TRANSLATION | crBoneData::ROTATION | crBoneData::SCALE) const;

	// PURPOSE: Returns if the skeleton is using Bone IDs.
	// RETURNS: true - if the skeleton uses bone IDs (see notes).
	// NOTES: Bone IDs provide a more flexible way of indexing bones in the frame and animation
	//	space.  Bone IDs are typically generated by hashing the bone names.  The use of
	//	bone IDs means animations and frames can support multiple different skeletons
	//	(within reason) and bones can be added and removed during the lifetime of a project with relative ease.
	//	If bone IDs are not used on a skeleton, then the ID found in frames and animations
	//	will be the same as the bone index in the skeleton.
	bool HasBoneIds() const;

	// PURPOSE: Converts a bone ID into a bone Index.
	// PARAMS: boneId - the bone ID to convert, outBoneIdx - the output bone Index (will be unchanged if conversion returns false)
	// RETURNS: true - if the conversion was possible.
	// NOTES: if Bone IDs are not used on the skeleton, the output will be the ID passed in.
	bool ConvertBoneIdToIndex(u16 boneId, int& outBoneIdx) const;

	// PURPOSE: Converts a bone Index into a bone ID.
	// PARAMS: boneIdx - the bone Index to convert, outBoneId - the output bone ID (will be unchanged if conversion returns false)
	// RETURNS: true - if the conversion was possible.
	// NOTES: if Bone IDs are not used on this skeleton, the output will be the Index passed in.
	bool ConvertBoneIndexToId(int boneIdx, u16& outBoneId) const;

	// PURPOSE: Returns parent indices table. Useful for optimizing operations involving frequent lookups of bone parents.
	// RETURNS: Pointer to parent indices table, NULL if none calculated.
	// NOTES: The parent indices table is a packed table of the parent index of each bone.
	// ie GetParentIndices()[12] == GetBone(12)->GetParent()->GetIndex()
	// Warning: Parent index of root bone is -1, ie GetParentIndices()[0] == -1.
	const s16* GetParentIndices() const;

	// PURPOSE: Returns entry from parent indices table.
	// PARAMS: boneIdx - the bone index of the bone to lookup.
	// RETURNS: Index of parent bone.
	// NOTES: Warning: Parent index of root bone is -1, ie GetParentIndex(0) == -1
	s32 GetParentIndex(int boneIdx) const;

	// PURPOSE: Returns pointer to default transform matrices, NULL if none present.
	// NOTES: The default transform matrices are a packed array of default transformation
	// matrices for the bones.  The benefit is that they are tightly packed, and
	// can save on extra conversions associated with using Euler rotation in the bone data.
	const Mat34V* GetDefaultTransforms() const;

	// PURPOSE: Returns entry from default matrices array
	// PARAMS: boneIdx - the bone index of the bone to lookup
	Mat34V_ConstRef GetDefaultTransform(int boneIdx) const;

	// PURPOSE: Compute the object transform that would result on a bone in a newly initialized skeleton
	// PARAMS:
	//	boneIdx - the bone index of the bone to compute
	//	result - where the resulting matrix will be stored
	void ComputeObjectTransform(int boneIdx, Mat34V_InOut result) const;

	// PURPOSE: Compute the global transform that would result on a bone in a newly initialized skeleton
	// PARAMS:
	//	boneIdx - the bone index of the bone to compute
	//	parentMtx - the parent matrix that the global matrix is computed using
	//	result - where the resulting matrix will be stored
	void ComputeGlobalTransform(int boneIdx, Mat34V_In parentMtx, Mat34V_InOut result) const;

	// PURPOSE:: Returns inverse cumulative joint scale orient matrices.
	// NOTES: Cumulative joint scale orient matrix is result of combining joint, translation and scale
	// of bone and all its parents in following way: (S[n] * J[n] * S[n-1] * J[n-1] * ... * S[0] * J[0])^-1
	const Mat34V* GetCumulativeInverseJoints() const;

	// PURPOSE:: Assign a new properties container.
	void SetProperties(crProperties* properties);

	// PURPOSE:: Retrieve the current properties container.
	const crProperties* GetProperties() const;

	// PURPOSE: Get skeleton signature (chiral)
	// RETURNS: skeleton signature (a hash value that identifies the skeleton's structure - zero indicates an invalid/no hash)
	// NOTES:
	// This is a signature on the skeleton's *structure* (i.e. pattern of bone ids/degrees of freedom)
	// This particular signature is sensitive to chirality (the order of the branches
	//   of child bones matters).  Use GetSignatureNonChiral to avoid this behavior.
	// The signature is also *not* sensitive to the default values of the bones
	//   (i.e. two skeletons can have the same structure/signature, but different default poses etc)
	//   Use GetSignatureComprehensive to avoid this, and have a signature sensitive to everything.
	u32 GetSignature() const;

	// PURPOSE: Get skeleton signature (non-chiral)
	// RETURNS: skeleton signature (a hash value that identifies the skeleton's structure - zero indicates an invalid/no hash)
	// NOTES:
	// This signature is insensitive to chirality, it cares only about the dofs and ids present in the skeleton (not their order)
	// If order is important, use GetSignature.  If default values are also important, use GetSignatureComprehensive
	u32 GetSignatureNonChiral() const;

	// PURPOSE: Get skeleton signature (comprehensive)
	// RETURNS: skeleton signature (a hash value that identifies the skeleton's structure and values - zero indicates an invalid/no hash)
	// NOTES:
	// This signature is sensitive to structure, order and default values of the skeleton.
	// See GetSignature and GetSignatureNonChiral for less encompassing signatures
	u32 GetSignatureComprehensive() const;

	// PURPOSE: Convert bone name string to id (via hashing)
	// PARAMS: boneIdName - bone name string
	// RETURNS: bone id hash value
	// NOTES: If the string starts with a '#' what follows is treated as a number and returned.  Otherwise the string is hashed (the hash guarantees not to
	// return 0, or other low numeric values - preserving these for use by the manual numbering system).
	static u16 ConvertBoneNameToId(const char* boneIdName);

	// PURPOSE: Debug only, uses static registry to attempt to convert id back into name
	static const char* DebugConvertBoneIdToName(u16 id);

	// PURPOSE: Debug only, register external id to name mapping
	static bool DebugRegisterBoneIdToName(u16 id, const char* name);
	
	// PURPOSE: Generate mirror indices
	void GenerateMirrorIndices();
	void GenerateMirrorIndices2();

	// PURPOSE: Get child parent indices array used for skeleton update
	const u16* GetChildParentIndices() const;

	// PURPOSE: Get number of indices inside the child parent array
	u32 GetNumChildParents() const;

	const atMap<u32,int>& GetBoneIdTable() const;

protected:
#if !CR_DEV
	// PURPOSE: Private copy constructor, not implemented and should never be used
	crSkeletonData(const crSkeletonData&);
#endif

	// PURPOSE: Internal initialization
	void Init();

	// PURPOSE: Generate child parent indices from bone hierarchy
	void GenerateChildParentIndices();

	atMap<u32,int> m_BoneIdTable;

	datRef<crBoneData> m_Bones;
	datRef<Mat34V> m_CumulativeInverseTransforms;
	datRef<Mat34V> m_DefaultTransforms;
	datRef<s16> m_ParentIndices;
	datRef<u16> m_ChildParentIndices;
	datOwner<crProperties> m_Properties;

	u32 m_Signature;
	u32 m_SignatureNonChiral;
	u32 m_SignatureComprehensive;

	mutable u16 m_RefCount;
	u16 m_NumBones;
	u16 m_NumChildParents;
	u16 m_Padding;
};

////////////////////////////////////////////////////////////////////////////////

inline void crSkeletonData::AddRef() const
{
	++m_RefCount;
}

////////////////////////////////////////////////////////////////////////////////

inline int crSkeletonData::Release() const
{
	if (!--m_RefCount)
	{
		delete this;
		return 0;
	}
	else
	{
		return m_RefCount;
	}
}

////////////////////////////////////////////////////////////////////////////////

inline int crSkeletonData::GetNumBones() const
{
	return m_NumBones;
}

////////////////////////////////////////////////////////////////////////////////

inline crBoneData* crSkeletonData::GetBoneData(int boneIdx)
{
	FastAssert(m_Bones && boneIdx >= 0 && boneIdx < m_NumBones);
	return &m_Bones[boneIdx];
}

////////////////////////////////////////////////////////////////////////////////

inline const crBoneData* crSkeletonData::GetBoneData(int boneIdx) const
{
	FastAssert(m_Bones && boneIdx >= 0 && boneIdx < m_NumBones);
	return &m_Bones[boneIdx];
}

////////////////////////////////////////////////////////////////////////////////

inline const crBoneData* crSkeletonData::GetBones() const
{
	return m_Bones;
}

////////////////////////////////////////////////////////////////////////////////

inline crBoneData* crSkeletonData::GetBones()
{
	return m_Bones;
}

////////////////////////////////////////////////////////////////////////////////

inline bool crSkeletonData::HasBoneIds() const
{
	return m_BoneIdTable.GetNumUsed() > 0;
}

////////////////////////////////////////////////////////////////////////////////

inline const s16* crSkeletonData::GetParentIndices() const
{
	return m_ParentIndices;
}

////////////////////////////////////////////////////////////////////////////////

inline s32 crSkeletonData::GetParentIndex(int boneIdx) const
{
	FastAssert(m_ParentIndices && boneIdx >= 0 && boneIdx < m_NumBones);
	return m_ParentIndices[boneIdx];
}

////////////////////////////////////////////////////////////////////////////////

inline const Mat34V* crSkeletonData::GetDefaultTransforms() const
{
	return m_DefaultTransforms;
}

////////////////////////////////////////////////////////////////////////////////

inline Mat34V_ConstRef crSkeletonData::GetDefaultTransform(int boneIdx) const
{
	FastAssert(m_DefaultTransforms && boneIdx >= 0 && boneIdx < m_NumBones);
	return m_DefaultTransforms[boneIdx];
}

////////////////////////////////////////////////////////////////////////////////

inline const Mat34V* crSkeletonData::GetCumulativeInverseJoints() const
{
	return m_CumulativeInverseTransforms;
}

////////////////////////////////////////////////////////////////////////////////

inline const crProperties* crSkeletonData::GetProperties() const
{
	return m_Properties;
}

////////////////////////////////////////////////////////////////////////////////

inline u32 crSkeletonData::GetSignature() const
{
	return m_Signature;
}

////////////////////////////////////////////////////////////////////////////////

inline u32 crSkeletonData::GetSignatureNonChiral() const
{
	return m_SignatureNonChiral;
}

////////////////////////////////////////////////////////////////////////////////

inline u32 crSkeletonData::GetSignatureComprehensive() const
{
	return m_SignatureComprehensive;
}

////////////////////////////////////////////////////////////////////////////////

inline const u16* crSkeletonData::GetChildParentIndices() const
{
	return m_ChildParentIndices;
}

////////////////////////////////////////////////////////////////////////////////

inline u32 crSkeletonData::GetNumChildParents() const
{
	return m_NumChildParents;
}

////////////////////////////////////////////////////////////////////////////////

inline const atMap<u32,int>& crSkeletonData::GetBoneIdTable() const
{
	return m_BoneIdTable;
}

////////////////////////////////////////////////////////////////////////////////

}	// namespace rage

#endif // CRSKELETON_SKELETONDATA_H
