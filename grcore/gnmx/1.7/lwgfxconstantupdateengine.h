/* SCE CONFIDENTIAL
PlayStation(R)4 Programmer Tool Runtime Library Release 01.700.081
* Copyright (C) 2013 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/

#if !defined(_SCE_GNMX_LWGFXCONSTANTUPDATEENGINE_H)
#define _SCE_GNMX_LWGFXCONSTANTUPDATEENGINE_H

#include "lwbaseconstantupdateengine.h"

namespace sce
{
	namespace Gnmx
	{
		namespace LightweightConstantUpdateEngine
		{

			/** @brief Lightweight ConstantUpdateEngine for graphics context */
			class SCE_GNMX_EXPORT GraphicsConstantUpdateEngine : public BaseConstantUpdateEngine
			{
			public:

				/** @brief Initializes the resource areas for the Graphics constant updates.
				 *  @param resourceBuffersInGarlic Array of resource buffers to be used by the GraphicsCUE.
				 *  @param resourceBufferCount Number of resource buffers created.
				 *  @param resourceBufferSizeInDwords Size of each resource buffer.
				 *  @param globalInternalResourceTableAddr A pointer to the global resource table in memory.
				 */
				void init(uint32_t** resourceBuffersInGarlic, int32_t resourceBufferCount, int32_t resourceBufferSizeInDwords, void* globalInternalResourceTableAddr);


				/** @brief Swap LCUE's GraphicsCUE buffers for the next frame. */
				void swapBuffers();


				/** @brief Sets the pointer to the draw command buffer.
				 *  @param dcb Pointer to the draw command buffer.
				 */
				SCE_GNM_FORCE_INLINE void setDrawCommandBuffer(sce::Gnm::DrawCommandBuffer* dcb) { m_dcb = dcb; }


				/** @brief Sets the active shader stages in the graphics pipeline.
				 *  @param activeStages Indicates which shader stages should be activated.
				 *  @note by default, the setting of setGsMode is handled automatically  
				 *  by the Lightweight ConstantUpdateEngine when <c><i>activeStages</i></c> is set to either kActiveShaderStagesEsGsVsPs or kActiveShaderStagesLsHsEsGsVsPs.
				 */
				SCE_GNM_FORCE_INLINE void setActiveShaderStages(Gnm::ActiveShaderStages activeStages)
				{ 
					m_activeShaderStages = activeStages;
		
					// Changing GsMode rolls the hardware context, so just change it when it's really necessary
					bool geometryShaderActive = (activeStages == Gnm::kActiveShaderStagesEsGsVsPs) | (activeStages == Gnm::kActiveShaderStagesLsHsEsGsVsPs);
					if (m_gsMode != Gnm::kGsModeDisable && !geometryShaderActive)
					{
						m_dcb->setGsMode(Gnm::kGsModeDisable, Gnm::kGsMaxOutputVertexCount1024);
						m_gsMode = Gnm::kGsModeDisable;
						m_gsMaxOutput = Gnm::kGsMaxOutputVertexCount1024;
					}
				}

				/** @brief Binds a ES shader to the ES stage.
				 *  @param shader Pointer to the ES shader.
				 *  @param shaderModifier Shader modifier value generated by generateEsFetchShaderBuildState(); use 0 if no fetch shader.
				 *  @param fetchShader If the shader requires a fetch shader, pass its GPU address here. Otherwise, pass NULL.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setEsShader(const sce::Gnmx::EsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a ES shader to the ES stage without a fetch shader.
				 *  @param shader Pointer to the ES shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				SCE_GNM_FORCE_INLINE void setEsShader(const sce::Gnmx::EsShader* shader, const InputResourceOffsets* table) { setEsShader(shader, 0, NULL, table); }


				/** @brief Binds a ES shader to the ES stage.
				 *  @param shader Pointer to the ES shader.
				 *  @param ldsSizeIn512Bytes The LDS allocation size in 512-byte granularity allocation units. Internally, this value will be passed to
				 *                           EsStageRegisters::updateLdsSize() before the EsShader is bound. If this parameter is 0, the function behaves
				 *                           identically to ConstantUpdateEngine::setEsShader().
				 *  @param shaderModifier Shader modifier value generated by generateEsFetchShaderBuildState(); use 0 if no fetch shader.
				 *  @param fetchShader If the shader requires a fetch shader, pass its GPU address here. Otherwise, pass NULL.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 *  @see Gnmx::computeOnChipGsConfiguration()
				 */
				void setOnChipEsShader(const Gnmx::EsShader *shader, uint32_t ldsSizeIn512Bytes, uint32_t shaderModifier, const void *fetchShader, const InputResourceOffsets* table);

				/** @brief Binds a ES shader to the ES stage without a fetch shader.
				 *  @param shader Pointer to the ES shader.
				 *  @param ldsSizeIn512Bytes The LDS allocation size in 512-byte granularity allocation units. Internally, this value will be passed to
				 *                           EsStageRegisters::updateLdsSize() before the EsShader is bound. If this parameter is 0, the function behaves
				 *                           identically to ConstantUpdateEngine::setEsShader().
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 *  @see Gnmx::computeOnChipGsConfiguration()
				 */
				SCE_GNM_FORCE_INLINE void setOnChipEsShader(const Gnmx::EsShader *shader, uint32_t ldsSizeIn512Bytes, const InputResourceOffsets* table) { setOnChipEsShader(shader, ldsSizeIn512Bytes, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the ES stage. Use for late fetch shader binding or updating fetch shader.
				 *  @param shaderModified Shader modifier value generated by generateEsFetchShaderBuildState().
				 *  @param fetchShader Pointer to the fetch shader.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*fetchShader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setEsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a GS shader to the GS and VS stages.
				 *  This function will roll hardware context if any of the Gnm::GsStageRegisters entries set in the GsShader specified in (<c><i>*shader</i></c>)
				 *  or the Gnm::VsStageRegisters entries set for the copy shader specified in GsShader::getCopyShader() call to the shader specified in
				 *  <c><i>*shader</i></c>) are different from current state:
				 *
				 *  Gnm::GsStageRegisters
				 *  - <c>m_vgtStrmoutConfig</c>
				 *  - <c>m_vgtGsOutPrimType</c>
				 *  - <c>m_vgtGsInstanceCnt</c>
				 *
				 *  Gnm::VsStageRegisters
				 *  - <c>m_spiVsOutConfig</c>
				 *  - <c>m_spiShaderPosFormat</c>
				 *  - <c>m_paClVsOutCntl</c>
				 * 
				 *  @param shader Pointer to a GS shader to bind to the GS/VS stages.
				 *  @param gsTable Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setGsVsShaders() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setGsVsShaders(const sce::Gnmx::GsShader* shader, const InputResourceOffsets* gsTable);
				
				
				/** @brief Binds an on-chip GS shader to the GS and VS stages and sets up the on-chip GS sub-group size controls.
				 *  This function will roll hardware context if any of the Gnm::GsStageRegisters entries set in the GsShader specified in (<c><i>*shader</i></c>)
				 *  or the Gnm::VsStageRegisters entries set for the copy shader specified in GsShader::getCopyShader() call to the shader specified in 
				 *  <c><i>*shader</i></c>) are different from current state:
				 *
				 *  Gnm::GsStageRegisters
				 *  - <c>m_vgtStrmoutConfig</c>
				 *  - <c>m_vgtGsOutPrimType</c>
				 *  - <c>m_vgtGsInstanceCnt</c>
				 *
				 *  Gnm::VsStageRegisters
				 *  - <c>m_spiVsOutConfig</c>
				 *  - <c>m_spiShaderPosFormat</c>
				 *  - <c>m_paClVsOutCntl</c>
				 * 
				 *  This function will also roll context if the value of gsPrimsPerSubGroup or gsb->m_inputVertexCount changes.
				 *
				 *  @param shader Pointer to a GS shader to bind to the GS/VS stages.
				 *  @param gsPrimsPerSubGroup The number of GS threads which will be launched per on-chip-GS LDS allocation, which must be compatible with the size of the LDS allocation passed to setOnChipEsShaders.
				 *  @param gsTable Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setGsVsShaders() is called again, all resource bindings for the stage will need to be re-bound.
				 *  @see Gnmx::computeOnChipGsConfiguration()
				 */
				void setOnChipGsVsShaders(const sce::Gnmx::GsShader* shader, uint32_t gsPrimsPerSubGroup, const InputResourceOffsets* gsTable);

				
				/** @brief Sets the layout of the LDS area where data will flow from the ES to the GS stages when on-chip geometry shading is enabled.
				 *  This sets the same context register state as setEsGsRingBuffer(NULL, 0, maxExportVertexSizeInDword), but does not modify the global resource table.
				 *
				 *  This function will roll hardware context.
				 *
				 *  @param maxExportVertexSizeInDword The stride of an ES-GS vertex in dwords, which must match EsShader::m_maxExportVertexSizeInDword.
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This binding requires setOnChipEsShader() be called prior to binding.
				 */
				SCE_GNM_FORCE_INLINE void setOnChipEsGsLdsLayout(uint32_t maxExportVertexSizeInDword)
				{
					setOnChipEsExportVertexSizeInDword((uint16_t)maxExportVertexSizeInDword);
					m_dcb->setupEsGsRingRegisters(maxExportVertexSizeInDword);
				}


				/** @brief Description to be specified
				 *
				 *  This function never rolls the hardware context.
				 *
				 *  @param onChipEsVertsPerSubGroup
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note Set internally by setOnChipGsVsShaders()
				 */
				void setOnChipEsVertsPerSubGroup(uint16_t onChipEsVertsPerSubGroup);

				
				/** @brief Specifies the size of vertices in Dwords exported by the ES shader stage.
				 *
				 *  This function never rolls the hardware context.
				 *
				 *  @param onChipEsExportVertexSizeInDword
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @see Gnmx::EsShader::m_memExportVertexSizeInDWord
				 */
				void setOnChipEsExportVertexSizeInDword(uint16_t onChipEsExportVertexSizeInDword);


				/** @brief Binds one or more streamout buffer objects to the specified shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxStreamOutBufferCount-1].     
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer The buffer objects to bind to the specified slots.
				 *	buffer[0] will be bound to <c><i>startApiSlot</i></c>, buffer[1] to <c><i>startApiSlot+1</i></c>, and so on. 
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setStreamoutBuffers(int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds a LS shader to the LS stage.
				 *  @param shader Pointer to the LS shader.
				 *  @param shaderModifier Shader Modifier value generated by generateLsFetchShaderBuildState(), use 0 if no fetch shader.
				 *  @param fetchShader If the shader requires a fetch shader, pass its GPU address here. Otherwise, pass NULL.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setLsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setLsShader(const sce::Gnmx::LsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a LS shader to the LS stage without a fetch shader.
				 *  @param shader Pointer to the LS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setLsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				SCE_GNM_FORCE_INLINE void setLsShader(const sce::Gnmx::LsShader* shader, const InputResourceOffsets* table) { setLsShader(shader, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the LS stage. Use for late fetch shader binding or updating fetch shader.
				 *  @param shaderModified Shader Modifier value generated by generateLsFetchShaderBuildState().
				 *  @param fetchShader Pointer to the fetch shader.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*fetchShader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setLsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a HS shader to the HS stage.
				 *  @param shader Pointer to the HS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @param tgPatchCount User desired patch count per thread group
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setHsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setHsShader(const sce::Gnmx::HsShader* shader, const InputResourceOffsets* table, uint32_t tgPatchCount);


				/** @brief Binds a VS shader to the VS stage.
				 *  @param shader Pointer to the VS shader.
				 *  @param shaderModifier Shader Modifier value generated by generateVsFetchShaderBuildState(), use 0 if no fetch shader.
				 *  @param fetchShader If the shader requires a fetch shader, pass its GPU address here. Otherwise, pass NULL.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*fetchShader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setVsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setVsShader(const sce::Gnmx::VsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a VS shader to the VS stage without a fetch shader.
				 *  @param shader Pointer to the VS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setVsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				SCE_GNM_FORCE_INLINE void setVsShader(const sce::Gnmx::VsShader* shader, const InputResourceOffsets* table) { setVsShader(shader, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the VS shader stage. Use for late fetch shader binding or updating fetch shader.
				 *  @param shaderModified Shader Modifier value generated by generateVsFetchShaderBuildState().
				 *  @param fetchShader Pointer to the fetch shader.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*fetchShader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setVsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a PS shader to the PS stage.
				 *  @param shader Pointer to the PS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setPsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setPsShader(const sce::Gnmx::PsShader* shader, const InputResourceOffsets* table);


				/** @brief Binds a CS shader to the CS stage.
				 *  @param shader Pointer to the CS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDispatch() is called.
				 *  @note This function must be called first before any resource bindings calls. If setCsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setCsShader(const sce::Gnmx::CsShader* shader, const InputResourceOffsets* table);


				/** @brief Specifies a range of the Global Data Store to be used by shaders for atomic global counters such as those
				 *  used to implement PSSL <c>AppendRegularBuffer</c> and <c>ConsumeRegularBuffer</c> objects.
				 *
				 *  Each counter is a 32-bit integer. The counters for each shader stage may have a different offset in GDS. For example:
				 *  @code
				 *     setAppendConsumeCounterRange(kShaderStageVs, 0x0100, 12) // Set up 3 counters for the VS stage starting at offset 0x100.
				 *     setAppendConsumeCounterRange(kShaderStageCs, 0x0400, 4)  // Set up 1 counter for the CS stage at offset 0x400.
				 *	@endcode
				 *
				 *  The index is defined by the chosen slot in the PSSL shader. For example:
				 *  @code
				 *     AppendRegularBuffer<uint> appendBuf : register(u3) // Will access the 4th counter starting at the base offset provided to this function.
				 *  @endcode
				 *
				 *  This function never rolls the hardware context.
				 *
				 *  @param shaderStage The shader stage to bind this counter range to.
				 *  @param gdsMemoryBaseInBytes The byte offset to the start of the counters in GDS. Must be a multiple of 4.
				 *  @param countersSizeInBytes The size of the counter range in bytes. Must be a multiple of 4.
				 *  @note GDS accessible size is provided by sce::Gnm::kGdsAccessibleMemorySizeInBytes. 
				 */
				void setAppendConsumeCounterRange(sce::Gnm::ShaderStage shaderStage, uint32_t gdsMemoryBaseInBytes, uint32_t countersSizeInBytes);


				/** @brief Specifies a range of the Global Data Store to be used by shaders.
				 *
				 *  This function never rolls the hardware context.
				 *
				 *  @param stage The shader stage to bind this range to.
				 *  @param baseOffsetInBytes The byte offset to the start of the range in GDS. Must be a multiple of 4. 
				 *  @param rangeSizeInBytes The size of the counter range in bytes. Must be a multiple of 4.
				 *  @note  GDS accessible size is provided by sce::Gnm::kGdsAccessibleMemorySizeInBytes. It is an error to specify a range outside these bounds.
				 */
				void setGdsMemoryRange(sce::Gnm::ShaderStage stage, uint32_t baseOffsetInBytes, uint32_t rangeSizeInBytes);

				
				/** @brief Binds one or more constant buffer objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxConstantBufferCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setConstantBuffers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more vertex buffer objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxVertexBufferCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer The constant buffer objects to bind to the specified slots.
				 *	buffer[0] will be bound to <c><i>startApiSlot</i></c>, buffer[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setVertexBuffers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read-only buffer objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxResourceCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer The buffer objects to bind to the specified slots.
				 *	buffer[0] will be bound to <c><i>startApiSlot</i></c>, buffer[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note Buffers and Textures share the same pool of API slots.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setBuffers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read/write buffer objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxRwResourceCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer The rwbuffer objects to bind to the specified slots.
				 *	buffer[0] will be bound to <c><i>startApiSlot</i></c>, buffer[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note rwBuffers and rwTextures share the same pool of API slots.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setRwBuffers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read-only texture objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxResourceCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param texture The texture objects to bind to the specified slots.
				 *	texture[0] will be bound to <c><i>startApiSlot</i></c>, texture[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note Buffers and Textures share the same pool of API slots.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setTextures(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Texture* texture);


				/** @brief Binds one or more read/write texture objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxRwResourceCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param texture The rwtexture objects to bind to the specified slots.
				 *	texture[0] will be bound to <c><i>startApiSlot</i></c>, texture[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note rwBuffers and rwTextures share the same pool of API slots.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setRwTextures(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Texture* texture);


				/** @brief Binds one or more sampler objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxSamplerCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param sampler The sampler objects to bind to the specified slots. 
				 *  sampler[0] will be bound to <c><i>startApiSlot</i></c>, sampler[1] to <c><i>startApiSlot+1</i></c>, and so on. 
				 *  The contents of these Sampler objects are cached locally inside the LCUE's scratch buffer.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setSamplers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Sampler* sampler);


				/** @brief Binds a user SRT buffer.
				 *  @param shaderStage	The shader stage to bind the SRT buffer to.
				 *  @param buffer		Pointer to the buffer. If NULL, <c><i>bufSizeInDwords</i></c> must be 0.
				 *  @param sizeInDwords	Size of the data pointed to by <c><i>buffer</i></c> in dwords. Valid range is [1..kMaxSrtUserDataCount] if <c><i>buffer</i></c> is non-NULL.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setUserSrtBuffer(sce::Gnm::ShaderStage shaderStage, const void* buffer, uint32_t sizeInDwords);


				//////////// Draw commands

				/** @brief Inserts a draw call using auto generated indices.
				 *
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
				 *
				 *	@param indexCount  The index up to which to auto generate the indices.
				 *	@see Gnm::DrawCommandBuffer::setPrimitiveType()
				 */
				SCE_GNM_FORCE_INLINE void drawIndexAuto(uint32_t indexCount)
				{
					SCE_GNM_VALIDATE(!isVertexOrInstanceOffsetEnabled(), "Using a shader that is expecting a vertex and/or instance offset without specifing them");

					preDraw();
					m_dcb->drawIndexAuto(indexCount);
				}


				/** @brief Inserts a draw call using auto generated indices while adding an offset to the vertex and instance indexes.
				 *
				 *  Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
				 *
				 *  @param indexCount		The index up to which to auto generate the indices.
				 *  @param vertexOffset		The offset added to each vertex index.
				 *	@param instanceOffset	The offset added to each instance index.
				 *	@see Gnm::DrawCommandBuffer::setPrimitiveType()
				 */
				SCE_GNM_FORCE_INLINE void drawIndexAuto(uint32_t indexCount, uint32_t vertexOffset, uint32_t instanceOffset)
				{
					setVertexAndInstanceOffset(vertexOffset,instanceOffset);
					
					preDraw();
					m_dcb->drawIndexAuto(indexCount);
				}


				/** @brief Inserts a draw call using streamout output.
				 *	
				 *	Draw commands never roll the hardware context, but use the current context such that the next command that sets context state will roll context.
				 *	
				 *	@see Gnm::DrawCommandBuffer::setPrimitiveType()
				 */
				SCE_GNM_FORCE_INLINE void drawOpaque()
				{
					SCE_GNM_VALIDATE(!isVertexOrInstanceOffsetEnabled(), "Using a shader that is expecting a vertex and/or instance offset without specifing them");

					preDraw();
					m_dcb->drawOpaqueAuto();
				}


				/** @brief Inserts a draw call using streamout output while adding an offset to the vertex and instance indexes.
				 *
				 *	Draw commands never roll the hardware context, but use the current context such that the next command that sets context state will roll context.
				 *
				 *	@param vertexOffset		The offset added to each vertex index.
				 *	@param instanceOffset	The offset added to each instance index.
				 *	@see Gnm::DrawCommandBuffer::setPrimitiveType()
				 */
				SCE_GNM_FORCE_INLINE void drawOpaque(uint32_t vertexOffset, uint32_t instanceOffset)
				{
					setVertexAndInstanceOffset(vertexOffset,instanceOffset);

					preDraw();
					m_dcb->drawOpaqueAuto();
				}


				/** @brief Inserts a draw call using provided indices, which are inserted into the command buffer.
				 *
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
				 *
				 *	@param indexCount			The number of indices to insert.
				 *	@param indices				A pointer to the first index in the buffer containing <c><i>indexCount</i></c> indices. The pointer should be 4-byte aligned.
				 *	@param indicesSizeInBytes	The size of the buffer pointed to by <c><i>indices</i></c> in bytes. To specify the size of individual indices, use setIndexSize().
				 *	@see Gnm::DrawCommandBuffer::setPrimitiveType(), Gnm::DrawCommandBuffer::setIndexSize()
				 */
				SCE_GNM_FORCE_INLINE void drawIndexInline(uint32_t indexCount, const void *indices, uint32_t indicesSizeInBytes)
				{
					SCE_GNM_VALIDATE(!isVertexOrInstanceOffsetEnabled(), "Using a shader that is expecting a vertex and/or instance offset without specifing them");

					preDraw();
					m_dcb->drawIndexInline(indexCount, indices, indicesSizeInBytes);
				}


				/** @brief Inserts a draw call using provided indices, which are inserted into the command buffer, while adding an offset to the vertex and instance indexes.
				 *
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
			     *
				 *	@param indexCount			The number of indices to insert.
				 *	@param indices				A pointer to the first index in the buffer containing <c><i>indexCount</i></c> indices. The pointer should be 4-byte aligned.
				 *	@param indicesSizeInBytes	The size of the buffer pointed to by <c><i>indices</i></c> in bytes. To specify the size of individual indices, use setIndexSize().
				 *	@param vertexOffset			The offset added to each vertex index.
				 *	@param instanceOffset		The offset added to each instance index.
				 *	@see Gnm::DrawCommandBuffer::setPrimitiveType(), Gnm::DrawCommandBuffer::setIndexSize()
				 */
				SCE_GNM_FORCE_INLINE void drawIndexInline(uint32_t indexCount, const void *indices, uint32_t indicesSizeInBytes, uint32_t vertexOffset, uint32_t instanceOffset)
				{
					setVertexAndInstanceOffset(vertexOffset,instanceOffset);

					preDraw();
					m_dcb->drawIndexInline(indexCount, indices, indicesSizeInBytes);
				}


				/** @brief Inserts a draw call using indices which are located in memory.
				 *
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
			     *
				 *	@param indexCount	The number of indices to insert.
				 *	@param indexAddr	The GPU address of the index buffer.
				 *	@see Gnm::DrawCommandBuffer::setPrimitiveType(), Gnm::DrawCommandBuffer::setIndexSize()
				 */
				SCE_GNM_FORCE_INLINE void drawIndex(uint32_t indexCount, const void *indexAddr)
				{
					SCE_GNM_VALIDATE(!isVertexOrInstanceOffsetEnabled(), "Using a shader that is expecting a vertex and/or instance offset without specifing them");

					preDraw();
					m_dcb->drawIndex(indexCount, indexAddr);
				}


				/** @brief Inserts a draw call using indices which are located in memory, while adding an offset to the vertex and instance indexes.
				 *
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
			     *
				 *	@param indexCount		The number of indices to insert.
				 *	@param indexAddr		The GPU address of the index buffer.
				 *	@param vertexOffset		The offset added to each vertex index.
				 *	@param instanceOffset	The offset added to each instance index.
				 *	@see Gnm::DrawCommandBuffer::setPrimitiveType(), Gnm::DrawCommandBuffer::setIndexSize()
				 */
				SCE_GNM_FORCE_INLINE void drawIndex(uint32_t indexCount, const void *indexAddr, uint32_t vertexOffset, uint32_t instanceOffset)
				{
					setVertexAndInstanceOffset(vertexOffset,instanceOffset);

					preDraw();
					m_dcb->drawIndex(indexCount, indexAddr);
				}


				/** @brief Inserts a draw call using indices which are located in memory and whose base, size, and element size were set previously.
				 *
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
				 *
				 *	@param indexOffset	The starting index number in the index buffer.
				 *	@param indexCount	The number of indices to insert.
				 *	@see Gnm::DrawCommandBuffer::setIndexBuffer(), Gnm::DrawCommandBuffer::setIndexCount(), Gnm::DrawCommandBuffer::setIndexSize()
				 */
				SCE_GNM_FORCE_INLINE void drawIndexOffset(uint32_t indexOffset, uint32_t indexCount)
				{
					SCE_GNM_VALIDATE(!isVertexOrInstanceOffsetEnabled(), "Using a shader that is expecting a vertex and/or instance offset without specifing them");

					preDraw();
					m_dcb->drawIndexOffset(indexOffset, indexCount);
				}


				/** @brief Inserts a draw call, using indices which are located in memory and whose base, size, and element size were set previously,
				 *		   while adding an offset to the vertex and instance indexes.
				 *
				 *	Draw commands never roll the hardware context, but use the current context such that the next command that sets context state will roll the context.
				 *
				 *	@param indexOffset		The starting index number in the index buffer.
				 *	@param indexCount		The number of indices to insert.
				 *	@param vertexOffset		The offset added to each vertex index.
				 *	@param instanceOffset	The offset added to each instance index.
				 *	@see Gnm::DrawCommandBuffer::setIndexBuffer(), Gnm::DrawCommandBuffer::setIndexCount(), Gnm::DrawCommandBuffer::setIndexSize()
				 */
				SCE_GNM_FORCE_INLINE void drawIndexOffset(uint32_t indexOffset, uint32_t indexCount, uint32_t vertexOffset, uint32_t instanceOffset)
				{
					setVertexAndInstanceOffset(vertexOffset,instanceOffset);

					preDraw();
					m_dcb->drawIndexOffset(indexOffset, indexCount);
				}

				/** @brief Issues an indirect draw call, which reads its parameters from a specified address in GPU memory.
				 *
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
				 *
				 *	@param dataOffsetInBytes	The offset (in bytes) into the indirect arguments buffer at which to read the parameters from.
				 *								The data at this offset should be a Gnm::DrawIndirectArgs structure.
				 *	@note The buffer containing the indirect arguments should already have been set using setBaseIndirectArgs().
				 *	@see Gnm::DrawIndirectArgs, Gnm::DrawCommandBuffer::setBaseIndirectArgs()
				 */
				SCE_GNM_FORCE_INLINE void drawIndirect(uint32_t dataOffsetInBytes)
				{
					// no need to set vertex and instance offsets here, they are coming from the draw indirect structure.
					preDraw();

					switch (m_activeShaderStages)
					{
						case sce::Gnm::kActiveShaderStagesVsPs:
						{
							const Gnmx::VsShader *pvs = (const Gnmx::VsShader*)m_boundShader[Gnm::kShaderStageVs];
							m_dcb->drawIndirect(dataOffsetInBytes, Gnm::kShaderStageVs, (uint8_t)pvs->getVertexOffsetUserRegister(), (uint8_t)pvs->getInstanceOffsetUserRegister());
							break;
						}
						case sce::Gnm::kActiveShaderStagesEsGsVsPs:
						{
							const Gnmx::EsShader *pes = (const Gnmx::EsShader*)m_boundShader[Gnm::kShaderStageEs];
							m_dcb->drawIndirect(dataOffsetInBytes, Gnm::kShaderStageEs, (uint8_t)pes->getVertexOffsetUserRegister(), (uint8_t)pes->getInstanceOffsetUserRegister());
							break;
						}
						case sce::Gnm::kActiveShaderStagesLsHsVsPs:
						case sce::Gnm::kActiveShaderStagesLsHsEsGsVsPs:
						{
							const Gnmx::LsShader *pls = (const Gnmx::LsShader*)m_boundShader[Gnm::kShaderStageLs];
							m_dcb->drawIndirect(dataOffsetInBytes, Gnm::kShaderStageLs, (uint8_t)pls->getVertexOffsetUserRegister(), (uint8_t)pls->getInstanceOffsetUserRegister());
							break;
						}
						case sce::Gnm::kActiveShaderStagesDispatchDrawVsPs:
						{
							SCE_GNM_ERROR("drawIndirect does not support DispatchDaw");
							break;
						}
						default:
						{
							SCE_GNM_ERROR("Unknown active shader stage is set, please ensure you have called setActiveShaderStages() prior to draw");
							break;
						}
					}
				}


				/** @brief Issues an indirect multi-draw call, which reads its parameters from a specified address in GPU memory.
				 *
				 *	This is similar to calling drawIndirect() several times, with multiple DrawIndirectArgs objects tightly packed in memory.
				 *	Draw commands never roll the hardware context, but use the current context such that the next command that sets context state will roll context.
				 *
				 *	@param dataOffsetInBytes	Offset (in bytes) into the buffer that contains the first draw call's indirect arguments, set using setBaseIndirectArgs().
				 *								The data at this offset should be a Gnm::DrawIndirectArgs structure.
				 *	@param drawCount			The number of draw calls to launch. Each draw reads a new DrawIndirectArgs object from the indirect arguments buffer.
				 *	@note The buffer containing the indirect arguments should already have been set using setBaseIndirectArgs().
				 *	@see Gnm::DrawIndexIndirectArgs, Gnm::DrawCommandBuffer::setBaseIndirectArgs()
				 */
				SCE_GNM_FORCE_INLINE void drawIndirectMulti(uint32_t dataOffsetInBytes, uint32_t drawCount)
				{
					// no need to set vertex and instance offsets here, they are coming from the draw indirect structure.
					preDraw();

					switch (m_activeShaderStages)
					{
						case sce::Gnm::kActiveShaderStagesVsPs:
						{
							const Gnmx::VsShader *pvs = (const Gnmx::VsShader*)m_boundShader[Gnm::kShaderStageVs];
							m_dcb->drawIndirectMulti(dataOffsetInBytes, drawCount, Gnm::kShaderStageVs, (uint8_t)pvs->getVertexOffsetUserRegister(), (uint8_t)pvs->getInstanceOffsetUserRegister());
							break;
						}
						case sce::Gnm::kActiveShaderStagesEsGsVsPs:
						{
							const Gnmx::EsShader *pes = (const Gnmx::EsShader*)m_boundShader[Gnm::kShaderStageEs];
							m_dcb->drawIndirectMulti(dataOffsetInBytes, drawCount, Gnm::kShaderStageEs, (uint8_t)pes->getVertexOffsetUserRegister(), (uint8_t)pes->getInstanceOffsetUserRegister());
							break;
						}
						case sce::Gnm::kActiveShaderStagesLsHsVsPs:
						case sce::Gnm::kActiveShaderStagesLsHsEsGsVsPs:
						{
							const Gnmx::LsShader *pls = (const Gnmx::LsShader*)m_boundShader[Gnm::kShaderStageLs];
							m_dcb->drawIndirectMulti(dataOffsetInBytes, drawCount, Gnm::kShaderStageLs, (uint8_t)pls->getVertexOffsetUserRegister(), (uint8_t)pls->getInstanceOffsetUserRegister());
							break;
						}
						case sce::Gnm::kActiveShaderStagesDispatchDrawVsPs:
						{
							SCE_GNM_ERROR("drawIndexIndirectMulti does not support DispatchDaw");
							break;
						}
						default:
						{
							SCE_GNM_ERROR("Unknown active shader stage is set, please ensure you have called setActiveShaderStages() prior to draw");
							break;
						}
					}
				}


				/** @brief Issues multiple indirect draw calls and has a similar effect to calling drawIndirect() several times
				 *		   with multiple DrawIndirectArgs objects tightly packed in memory.	
				 *
				 *  Draw commands never roll the hardware context but use the current context such that the next command that sets context state will roll context.
				 *
				 *  @param dataOffsetInBytes		The offset (in bytes) into the buffer that contains the first draw call's indirect arguments, which are set using setBaseIndirectArgs().
				 *				                    The data at this offset should be a Gnm::DrawIndirectArgs structure.
				 *  @param drawCount				The number of draw calls to launch. Each draw reads a new DrawIndirectArgs object from the indirect arguments buffer.
				 *  @param stage					The shader stage that contains the fetch shader.
				 *  @param vertexOffsetLocation		The user SGRPR where the fetch shader is expecting the vertex offset or 0 if not used.
				 *  @param instanceOffsetLocation	The user SGPR where the fetch shader is expecting the instance offset or 0 if not used.
				 *  @note The buffer containing the indirect arguments should already have been set using setBaseIndirectArgs().
				 *  @see Gnm::DrawIndirectArgs, Gnm::DrawCommandBuffer::setBaseIndirectArgs()
				 */
				void drawIndirectMulti(uint32_t dataOffsetInBytes, uint32_t drawCount, Gnm::ShaderStage stage, uint8_t vertexOffsetLocation, uint8_t instanceOffsetLocation)
				{
					// no need to set vertex and instance offsets here, they are coming from the draw indirect structure.
					preDraw();
					m_dcb->drawIndirectMulti(dataOffsetInBytes, drawCount, stage, vertexOffsetLocation, instanceOffsetLocation);
				}


				/** @brief Issues an indirect drawIndex call, which reads its parameters from a specified address in the GPU memory.
				 *
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
				 *
				 *	@param dataOffsetInBytes	The offset (in bytes) into the buffer that contains the indirect arguments, which is set using setBaseIndirectArgs().
				 *								The data at this offset should be a Gnm::DrawIndexIndirectArgs structure.
				 *
				 *	@note	The index buffer should already have been set up using setIndexBuffer() and setIndexCount(),
				 *			and the buffer containing the indirect arguments should have been set using setBaseIndirectArgs().
				 *			The index count in args->m_indexCountPerInstance will be clamped to the value passed to setIndexCount().
				 *	@see Gnm::DrawIndexIndirectArgs, Gnm::DrawCommandBuffer::setBaseIndirectArgs(), Gnm::DrawCommandBuffer::setIndexBuffer(), Gnm::DrawCommandBuffer::setIndexCount()
				 */
				SCE_GNM_FORCE_INLINE void drawIndexIndirect(uint32_t dataOffsetInBytes)
				{
					// no need to set vertex and instance offsets here, they are coming from the draw indirect structure.
					preDraw();

					switch (m_activeShaderStages)
					{
						case sce::Gnm::kActiveShaderStagesVsPs:
						{
							const Gnmx::VsShader *pvs = (const Gnmx::VsShader*)m_boundShader[Gnm::kShaderStageVs];
							m_dcb->drawIndexIndirect(dataOffsetInBytes, Gnm::kShaderStageVs, pvs->m_fetchControl&0xf, (pvs->m_fetchControl>>4)&0xf);
							break;
						}
						case sce::Gnm::kActiveShaderStagesEsGsVsPs:
						{
							const Gnmx::EsShader *pes = (const Gnmx::EsShader*)m_boundShader[Gnm::kShaderStageEs];
							m_dcb->drawIndexIndirect(dataOffsetInBytes, Gnm::kShaderStageEs, pes->m_fetchControl&0xf, (pes->m_fetchControl>>4)&0xf);
							break;
						}
						case sce::Gnm::kActiveShaderStagesLsHsVsPs:
						case sce::Gnm::kActiveShaderStagesLsHsEsGsVsPs:
						{
							const Gnmx::LsShader *pls = (const Gnmx::LsShader*)m_boundShader[Gnm::kShaderStageLs];
							m_dcb->drawIndexIndirect(dataOffsetInBytes, Gnm::kShaderStageLs, pls->m_fetchControl&0xf, (pls->m_fetchControl>>4)&0xf);
							break;
						}
						case sce::Gnm::kActiveShaderStagesDispatchDrawVsPs:
						{
							SCE_GNM_ERROR("drawIndexIndirect does not support DispatchDaw");
							break;
						}
						default:
						{
							SCE_GNM_ERROR("Unknown active shader stage is set, please ensure you have called setActiveShaderStages() prior to draw");
							break;
						}
					}
				}


				/** @brief Issues an indirect multi-draw call, which reads its parameters from a specified address in GPU memory.
				 *
				 *	This is similar to calling drawIndirect() several times, with multiple DrawIndirectArgs objects tightly packed in memory.
				 *	Draw commands never roll the hardware context but instead use the current context such that the next command that sets context state will roll the context.
				 *
				 *	@param dataOffsetInBytes	The offset (in bytes) into the buffer that contains the indirect arguments, which is set using setBaseIndirectArgs().
				 *								The data at this offset should be a Gnm::DrawIndexIndirectArgs structure.
				 *	@param drawCount			The number of draw calls to launch. Each draw reads a new DrawIndexIndirectArgs object from the indirect arguments buffer.
				 *	@note The index buffer and the buffer containing the indirect arguments should already have been set up using setIndexBuffer() and setIndexCount().
				 *		  The index count in args->m_indexCountPerInstance will be clamped to the value passed to setIndexCount().
				 *	@see Gnm::DrawIndexIndirectArgs, Gnm::DrawCommandBuffer::setBaseIndirectArgs(), Gnm::DrawCommandBuffer::setIndexBuffer(), Gnm::DrawCommandBuffer::setIndexCount()
				 */
				void drawIndexIndirectMulti(uint32_t dataOffsetInBytes, uint32_t drawCount)
				{
					// no need to set vertex and instance offsets here, they are coming from the draw indirect structure.
					preDraw();

					switch (m_activeShaderStages)
					{
						case sce::Gnm::kActiveShaderStagesVsPs:
						{
							const Gnmx::VsShader *pvs = (const Gnmx::VsShader*)m_boundShader[Gnm::kShaderStageVs];
							m_dcb->drawIndexIndirectMulti(dataOffsetInBytes, drawCount, Gnm::kShaderStageVs, pvs->m_fetchControl&0xf, (pvs->m_fetchControl>>4)&0xf);
							break;
						}
						case sce::Gnm::kActiveShaderStagesEsGsVsPs:
						{
							const Gnmx::EsShader *pes = (const Gnmx::EsShader*)m_boundShader[Gnm::kShaderStageEs];
							m_dcb->drawIndexIndirectMulti(dataOffsetInBytes, drawCount, Gnm::kShaderStageEs, pes->m_fetchControl&0xf, (pes->m_fetchControl>>4)&0xf);
							break;
						}
						case sce::Gnm::kActiveShaderStagesLsHsVsPs:
						case sce::Gnm::kActiveShaderStagesLsHsEsGsVsPs:
						{
							const Gnmx::LsShader *pls = (const Gnmx::LsShader*)m_boundShader[Gnm::kShaderStageLs];
							m_dcb->drawIndexIndirectMulti(dataOffsetInBytes, drawCount, Gnm::kShaderStageLs, pls->m_fetchControl&0xf, (pls->m_fetchControl>>4)&0xf);
							break;
						}
						case sce::Gnm::kActiveShaderStagesDispatchDrawVsPs:
						{
							SCE_GNM_ERROR("drawIndexIndirectMulti does not support DispatchDaw");
							break;
						}
						default:
						{
							SCE_GNM_ERROR("Unknown active shader stage is set, please ensure you have called setActiveShaderStages() prior to draw");
							break;
						}
					}
				}


				/** @brief Issues multiple indirect draw calls and has a similar effect to calling drawIndexIndirect() several times
				 *	   	   with multiple DrawIndirectArgs objects tightly packed in memory.
				 *
				 *	This is similar to calling drawIndexIndirect() several times, with multiple DrawIndirectArgs objects tightly packed in memory.
				 *	Draw commands never roll the hardware context but use the current context such that the next command that sets context state will roll context.
				 *
				 *	@param dataOffsetInBytes		The offset (in bytes) into the indirect arguments buffer at which to read the parameters from.
				 *									The data at this offset should be a Gnm::DrawIndexIndirectArgs structure.
				 *	@param drawCount				The number of draw calls to launch. Each draw reads a new DrawIndexIndirectArgs object from the indirect arguments buffer.
				 *	@param stage					The shader stage that contains the fetch shader.
				 *	@param vertexOffsetLocation		The user SGRPR where the fetch shader is expecting the vertex offset or 0 if not used.
				 *	@param instanceOffsetLocation	The user SGPR where the fetch shader is expecting the instance offset or 0 if not used.
				 *	@note The index buffer and the buffer containing the indirect arguments should already have been set up using setIndexBuffer() and setIndexCount(),
				 *		  and the buffer containing the indirect arguments should have been set using setBaseIndirectArgs().
				 *		  The index count in args->m_indexCountPerInstance will be clamped to the value passed to setIndexCount().
				 *	@see Gnm::DrawIndexIndirectArgs, Gnm::DrawCommandBuffer::setIndexBuffer(), Gnm::DrawCommandBuffer::setIndexCount(), Gnm::DrawCommandBuffer::setBaseIndirectArgs()
				 */
				void drawIndexIndirectMulti(uint32_t dataOffsetInBytes, uint32_t drawCount, Gnm::ShaderStage stage, uint8_t vertexOffsetLocation, uint8_t instanceOffsetLocation)
				{
					// no need to set vertex and instance offsets here, they are coming from the draw indirect structure.
					preDraw();
					m_dcb->drawIndexIndirectMulti(dataOffsetInBytes, drawCount, stage, vertexOffsetLocation, instanceOffsetLocation);
				}
				////////////// Dispatch commands

				/** @brief Inserts a compute shader dispatch with the indicated number of thread groups.
				 * 	This function never rolls the hardware context.
				 *	@param threadGroupX Number of thread groups dispatched along the X dimension.
				 *	@param threadGroupY Number of thread groups dispatched along the Y dimension.
				 *	@param threadGroupZ Number of thread groups dispatched along the Z dimension.
				 */
				SCE_GNM_FORCE_INLINE void dispatch(uint32_t threadGroupX, uint32_t threadGroupY, uint32_t threadGroupZ)
				{
					preDispatch();
					m_dcb->dispatch(threadGroupX, threadGroupY, threadGroupZ);
				}


				/** @brief Inserts an indirect compute shader dispatch, whose parameters are read from GPU memory.
				 *
				 *  This function never rolls the hardware context.
				 *
				 *  @param dataOffsetInBytes Offset (in bytes) into the buffer that contains the indirect arguments (set using <c>setBaseIndirectArgs()</c>).
				 *	The data at this offset should be a Gnm::DispatchIndirectArgs structure.
				 *  @note The buffer containing the indirect arguments should already have been set using <c>setBaseIndirectArgs()</c>.
				 *  @see Gnm::DispatchCommandBuffer::setBaseIndirectArgs
				 */
				SCE_GNM_FORCE_INLINE void dispatchIndirect(uint32_t dataOffsetInBytes)
				{
					preDispatch();
					m_dcb->dispatchIndirect(dataOffsetInBytes);
				}

				
				/** @brief Executes all previous enqueued resource and shader bindings in preparation for a draw call.
				 *
				 *  Dirty resource bindings will be flushed from the internal scratch buffer, and committed to the resource buffer
				 *
				 *  @note When using the Lightweight Constant Update Engine to manage shaders and shader resources, this function must be called 
				 *  immediately before every draw call
				 */
				void preDraw();

				
				/** @brief Executes all previous enqueued resource and shader bindings in preparation for a dispatch call.
				 *
				 *  Dirty resource bindings will be flushed from the internal scratch buffer, and committed to the resource buffer
				 *
				 *  @note When using the Lightweight Constant Update Engine to manage shaders and shader resources, this function must be called 
				 *  immediately before every draw call
				 */
				void preDispatch();


				/** @brief Sets the vertex and instance offset for the current shader configuration.
				 *
				 * The vertex and instance offsets work only when enabled in the vertex shader.
				 *
				 * @param vertexOffset		The offset added to each vertex index.
				 * @param instanceOffset	The offset added to instance index.
				 */
				void setVertexAndInstanceOffset(uint32_t vertexOffset, uint32_t instanceOffset);


				/** @brief Checks if the current shader configuration is expecting a vertex or instance offset.
				*/
				bool isVertexOrInstanceOffsetEnabled() const;

	#if !defined(DOXYGEN_IGNORE)

				SCE_GNM_LCUE_NOT_SUPPORTED
				void setInternalSrtBuffer(sce::Gnm::ShaderStage shaderStage, const void* buffer){ SCE_GNM_UNUSED(shaderStage); SCE_GNM_UNUSED(buffer);};

			protected:

				uint32_t						m_scratchBuffer[kGraphicsScratchBufferSizeInDwords];
				sce::Gnm::DrawCommandBuffer*	m_dcb;
				Gnm::ActiveShaderStages			m_activeShaderStages;

				// Each active shader stage has a pointer to inside the buffer where it should place its resources according to the offset table
				const void*					m_boundShader[sce::Gnm::kShaderStageCount];
				uint32_t					m_boundShaderAppendConsumeCounterRange[sce::Gnm::kShaderStageCount];
				uint32_t					m_boundShaderGdsMemoryRange[sce::Gnm::kShaderStageCount];
				const void*					m_boundFetchShader[sce::Gnm::kShaderStageCount];	// only for LS, ES or VS
				uint32_t					m_boundShaderModifier[sce::Gnm::kShaderStageCount]; // only for LS, ES or VS
				const InputResourceOffsets* m_boundShaderResourceOffsets[sce::Gnm::kShaderStageCount];
				
				bool m_dirtyShader[sce::Gnm::kShaderStageCount];
				bool m_dirtyShaderResources[sce::Gnm::kShaderStageCount];
		
				// Geometry Shader
				InputResourceOffsets m_fixedGsVsShaderResourceOffsets;					// Fixed offset table for the VS Copy shader for Geometry pipeline
				InputResourceOffsets m_fixedGsVsStreamOutShaderResourceOffsets;			// Fixed offset table for the VS Copy shader for Geometry pipeline with stream out
				InputResourceOffsets m_fixedOnChipGsVsShaderResourceOffsets;			// Fixed offset table for the on chip VS Copy shader for Geometry pipeline
				InputResourceOffsets m_fixedOnChipGsVsStreamOutShaderResourceOffsets;	// Fixed offset table for the on chip VS Copy shader for Geometry pipeline with stream out

				Gnm::GsMode m_gsMode;												// Last tracked GsMode
				Gnm::GsMaxOutputVertexCount m_gsMaxOutput;							// Last tracked GsMaxOutputVertexCount

				// GS/ES on-chip controls
				uint16_t	m_onChipEsVertsPerSubGroup;
				uint16_t	m_onChipEsExportVertexSizeInDword;
				uint32_t	m_onChipLdsSizeIn512Bytes;

				// Tessellation controls
				uint32_t	m_tessellationCurrentTgPatchCount;
				Gnm::Buffer m_tessellationCurrentCb;
				bool		m_tessellationAutoManageReservedCb;

				mutable ShaderResourceBindingValidation m_boundShaderResourcesValidation[sce::Gnm::kShaderStageCount];

			private:

				SCE_GNM_FORCE_INLINE uint32_t* flushScratchBuffer(sce::Gnm::ShaderStage shaderStage);
				SCE_GNM_FORCE_INLINE void updateOnChipParametersInUserDataSgprs(sce::Gnm::ShaderStage shaderStage);
				SCE_GNM_FORCE_INLINE void updateLsEsVsPtrsInUserDataSgprs(sce::Gnm::ShaderStage shaderStage, const uint32_t* resourceBufferFlushedAddress);
				SCE_GNM_FORCE_INLINE void updateCommonPtrsInUserDataSgprs(sce::Gnm::ShaderStage shaderStage, const uint32_t* resourceBufferFlushedAddress);
				SCE_GNM_FORCE_INLINE void updateEmbeddedCb(sce::Gnm::ShaderStage shaderStage, const sce::Gnmx::ShaderCommonData* shaderCommon);
				
				void preDrawTessellation(bool geometryShaderEnabled);
				void preDrawGeometryShader();

				void setUserData(sce::Gnm::ShaderStage shaderStage, int32_t startSgpr, int32_t sgprCount, const uint32_t* data);
				void setPtrInUserData(sce::Gnm::ShaderStage shaderStage, int32_t startSgpr, const void* gpuAddress);
	#endif // !defined(DOXYGEN_IGNORE)
			};


			/** @brief Encapsulates a Gnm::DrawCommandBuffer and Lightweight ConstantUpdateEngine (LCUE) and wraps them in a single higher-level interface.
			 *  This can be used as a main entry point into the PlayStation4 rendering API, or can be used in conjunction with the Gnmx::GfxContext 
			 *  see lwconstantupdateengine_cuetolcue.h for an example.
			 *  
			 *  Only functions that are overridden by the LCUE will be documented here. For information on other GraphicsContext functions, please
			 *  see the Gnmx::GfxContext reference.
			 */
			class SCE_GNMX_EXPORT GraphicsContext : public GraphicsConstantUpdateEngine
			{
			public:

				/** @brief Initializes a GraphicsContext with application-provided memory buffers for the LCUE.
				 *  @param dcbBuffer A buffer for use by the Draw Command Buffer.
				 *  @param dcbBufferSizeInDwords The size of <c><i>dcbBuffer</i></c>, in DWORDS.
				 *  @param resourceBufferInGarlic A resource buffer for use by the LCUE.
				 *  @param resourceBufferSizeInDwords The size of <c><i>resourceBufferInGarlic</i></c>, in DWORDS.
				 *  @param globalInternalResourceTableAddr A pointer to the global resource table in memory.
				 *  @param callbackFunc The callback to use when the dispatch command buffer (dcb) runs out of space for new commands.
				 *  @param callbackUserData User data to pass to <c><i>callbackFunc</i></c>.
				 */
				void init(uint32_t* dcbBuffer, int32_t dcbBufferSizeInDwords, uint32_t* resourceBufferInGarlic, int32_t resourceBufferSizeInDwords, 
						  uint32_t* globalInternalResourceTableAddr, sce::Gnm::CommandCallbackFunc callbackFunc, void *callbackUserData);


				/** @brief LCUE wrapper to sets the active shader stages in the graphics pipeline.
			 	 *	Note that the compute-only CS stage is always active.
			 	 *	This function will roll the hardware context.
				 *	@param activeStages Indicates which shader stages should be activated.
				 *  @note setGsMode will be automatically set by the LCUE
				 *	@cmdsize 3
				 */
				void setActiveShaderStages(Gnm::ActiveShaderStages activeStages)
				{
					GraphicsConstantUpdateEngine::setActiveShaderStages(activeStages);
					return m_dcb.setActiveShaderStages(activeStages);
				}


				/** @brief Sets the ring buffer where data will flow from the ES to the GS stages when geometry shading is enabled.
				 *  This function will roll hardware context.
				 *  @note This function modifies the global resource table. It is not safe to modify the global resource table unless the GPU graphics pipe is idle.
				 *  @param ringBuffer The address of the buffer.
				 *  @param ringSizeInBytes The size of the buffer in bytes.
				 *  @param maxExportVertexSizeInDword The maximum size of a vertex export in dwords.
				 */
				void setEsGsRingBuffer(void* ringBuffer, uint32_t ringSizeInBytes, uint32_t maxExportVertexSizeInDword);

				
				/** @brief Sets the ring buffers where data will flow from the GS to the VS stages when geometry shading is enabled.
				 *  This function will roll hardware context.
				 *  @note This function modifies the global resource table. It is not safe to modify the global resource table unless the GPU graphics pipe is idle.
				 *  @param ringBuffer The address of the buffer.
				 *  @param ringSize The size of the buffer in bytes.
				 *  @param vtxSizePerStreamInDword The vertex size for each of four streams in dwords.
				 *  @param maxOutputVtxCount The maximum number of vertices output from the GS stage.
				 */
				void setGsVsRingBuffers(void* ringBuffer, uint32_t ringSizeInBytes, const uint32_t vertexSizePerStreamInDword[4], uint32_t maxOutputVertexCount);


				/**
				 * @brief Sets the layout of the LDS area where data will flow from the GS to the VS stages when on-chip geometry shading is enabled.
				 * This sets the same context register state as setGsVsRingBuffers(NULL, 0, vtxSizePerStreamInDword, maxOutputVtxCount), but does not modify the global resource table.
				 *
				 * This function will roll hardware context.
				 * @param[in] vtxSizePerStreamInDword		The stride of GS-VS vertices for each of four streams in dwords, which must match GsShader::m_memExportVertexSizeInDWord[]. This pointer must not be NULL.
				 * @param[in] maxOutputVtxCount				The maximum number of vertices output from the GS stage, which must match GsShader::m_maxOutputVertexCount.
				 */
				void setOnChipGsVsLdsLayout(const uint32_t vtxSizePerStreamInDword[4], uint32_t maxOutputVtxCount)
				{
					m_dcb.setupGsVsRingRegisters(vtxSizePerStreamInDword, maxOutputVtxCount);
				}

				// gfxcontext_methods.h provides its own overrides, but we still need access to the parent class multi draws
				using GraphicsConstantUpdateEngine::drawIndirectMulti;
				using GraphicsConstantUpdateEngine::drawIndexIndirectMulti;

				// method forwarding to m_dcb 
				#include "lwgfxcontext_methods.h"

			public:
				sce::Gnm::DrawCommandBuffer m_dcb; ///< Draw command buffer. Access directly at your own risk!
				sce::Gnm::DispatchCommandBuffer m_acb; ///< Asynchronous compute dispatch command buffer. (Not used by the LCUE)
			};

		} // LightweightConstantUpdateEngine
	} // Gnmx
} // sce


#endif // _SCE_GNMX_LWGFXCONSTANTUPDATEENGINE_H