/* SCE CONFIDENTIAL
PlayStation(R)4 Programmer Tool Runtime Library Release 01.600.051
* Copyright (C) 2013 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/

#if !defined(_SCE_GNMX_LWGFXCONSTANTUPDATEENGINE_H)
#define _SCE_GNMX_LWGFXCONSTANTUPDATEENGINE_H

#include "lwbaseconstantupdateengine.h"

namespace sce
{
	namespace Gnmx
	{
		namespace LightweightConstantUpdateEngine
		{

			/** @brief Lightweight ConstantUpdateEngine for graphics context */
			class SCE_GNMX_EXPORT GraphicsConstantUpdateEngine : public BaseConstantUpdateEngine
			{
			public:

				/** @brief Initializes the resource areas for the Graphics constant updates.
				 *  @param resourceBuffersInGarlic Array of resource buffers to be used by the GraphicsCUE.
				 *  @param resourceBufferCount Number of resource buffers created.
				 *  @param resourceBufferSizeInDwords Size of each resource buffer.
				 *  @param globalInternalResourceTableAddr A pointer to the global resource table in memory.
				 */
				void init(uint32_t** resourceBuffersInGarlic, int32_t resourceBufferCount, int32_t resourceBufferSizeInDwords, void* globalInternalResourceTableAddr);

				/** @brief Swap LCUE's GraphicsCUE buffers for the next frame. */
				void swapBuffers();

				/** @brief Sets the pointer to the draw command buffer.
				 *  @param dcb Pointer to the draw command buffer.
				 */
				SCE_GNM_FORCE_INLINE void setDrawCommandBuffer(sce::Gnm::DrawCommandBuffer* dcb) { m_dcb = dcb; }

				/** @brief Sets the active shader stages in the graphics pipeline.
				 *  @param activeStages Indicates which shader stages should be activated.
				 *  @note by default, the setting of setGsMode is handled automatically  
				 *  by the Lightweight ConstantUpdateEngine when <c><i>activeStages</i></c> is set to either kActiveShaderStagesEsGsVsPs or kActiveShaderStagesLsHsEsGsVsPs.
				 */
				SCE_GNM_FORCE_INLINE void setActiveShaderStages(Gnm::ActiveShaderStages activeStages)
				{ 
					m_activeShaderStages = activeStages;
		
					// Changing GsMode rolls the hardware context, so just change it when it's really necessary
					bool geometryShaderActive = (activeStages == Gnm::kActiveShaderStagesEsGsVsPs) | (activeStages == Gnm::kActiveShaderStagesLsHsEsGsVsPs);
					if (m_gsMode != Gnm::kGsModeDisable && !geometryShaderActive)
					{
						m_dcb->setGsMode(Gnm::kGsModeDisable, Gnm::kGsMaxOutputVertexCount1024);
						m_gsMode = Gnm::kGsModeDisable;
						m_gsMaxOutput = Gnm::kGsMaxOutputVertexCount1024;
					}
				}

				/** @brief Binds a ES shader to the ES stage.
				 *  @param shader Pointer to the ES shader.
				 *  @param shaderModifier Shader modifier value generated by generateEsFetchShaderBuildState(); use 0 if no fetch shader.
				 *  @param fetchShader If the shader requires a fetch shader, pass its GPU address here. Otherwise, pass NULL.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setEsShader(const sce::Gnmx::EsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);

				/** @brief Binds a ES shader to the ES stage without a fetch shader.
				 *  @param shader Pointer to the ES shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setEsShader(const sce::Gnmx::EsShader* shader, const InputResourceOffsets* table) { setEsShader(shader, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the ES stage. Use for late fetch shader binding or updating fetch shader.
				 *  @param shaderModified Shader modifier value generated by generateEsFetchShaderBuildState().
				 *  @param fetchShader Pointer to the fetch shader.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*fetchShader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setEsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a GS shader to the GS and VS stages.
				 *  This function will roll hardware context if any of the Gnm::GsStageRegisters entries set in the GsShader (<c><i>*shader</i></c>)
				 *  or the Gnm::VsStageRegisters entries set for the copy shader (retrieved by GsShader::getCopyShader() in <c><i>*shader</i></c>), are different from current state:
				 *
				 *  Gnm::GsStageRegisters
				 *  - <c>m_vgtStrmoutConfig</c>
				 *  - <c>m_vgtGsOutPrimType</c>
				 *  - <c>m_vgtGsInstanceCnt</c>
				 *
				 *  Gnm::VsStageRegisters
				 *  - <c>m_spiVsOutConfig</c>
				 *  - <c>m_spiShaderPosFormat</c>
				 *  - <c>m_paClVsOutCntl</c>
				 * 
				 *  @param shader Pointer to a GS shader to bind to the GS/VS stages.
				 *  @param gsTable Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setGsVsShaders() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setGsVsShaders(const sce::Gnmx::GsShader* shader, const InputResourceOffsets* gsTable);
				
				
				/** @brief Binds a GS shader to the GS and VS stages.
				 *  This function will roll hardware context if any of the Gnm::GsStageRegisters entries set in the GsShader (<c><i>*shader</i></c>)
				 *  or the Gnm::VsStageRegisters entries set for the copy shader (retrieved by GsShader::getCopyShader() in <c><i>*shader</i></c>), are different from current state:
				 *
				 *  Gnm::GsStageRegisters
				 *  - <c>m_vgtStrmoutConfig</c>
				 *  - <c>m_vgtGsOutPrimType</c>
				 *  - <c>m_vgtGsInstanceCnt</c>
				 *
				 *  Gnm::VsStageRegisters
				 *  - <c>m_spiVsOutConfig</c>
				 *  - <c>m_spiShaderPosFormat</c>
				 *  - <c>m_paClVsOutCntl</c>
				 * 
				 *  @param shader Pointer to a GS shader to bind to the GS/VS stages.
				 *  @param gsTable Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setGsVsShaders() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setGsVsShadersOnChip(const sce::Gnmx::GsShader* shader, const InputResourceOffsets* gsTable);


				/** @brief Binds one or more streamout buffer objects to the specified shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxStreamOutBufferCount-1].     
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer The buffer objects to bind to the specified slots.
				 *	buffer[0] will be bound to <c><i>startApiSlot</i></c>, buffer[1] to <c><i>startApiSlot+1</i></c>, and so on. 
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setStreamoutBuffers(int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds a LS shader to the LS stage.
				 *  @param shader Pointer to the LS shader.
				 *  @param shaderModifier Shader Modifier value generated by generateLsFetchShaderBuildState(), use 0 if no fetch shader.
				 *  @param fetchShader If the shader requires a fetch shader, pass its GPU address here. Otherwise, pass NULL.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setLsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setLsShader(const sce::Gnmx::LsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a LS shader to the LS stage without a fetch shader.
				 *  @param shader Pointer to the LS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setLsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setLsShader(const sce::Gnmx::LsShader* shader, const InputResourceOffsets* table) { setLsShader(shader, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the LS stage. Use for late fetch shader binding or updating fetch shader.
				 *  @param shaderModified Shader Modifier value generated by generateLsFetchShaderBuildState().
				 *  @param fetchShader Pointer to the fetch shader.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*fetchShader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setLsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a HS shader to the HS stage.
				 *  @param shader Pointer to the HS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @param tgPatchCount User desired patch count per thread group
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setHsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setHsShader(const sce::Gnmx::HsShader* shader, const InputResourceOffsets* table, uint32_t tgPatchCount);


				/** @brief Binds a VS shader to the VS stage.
				 *  @param shader Pointer to the VS shader.
				 *  @param shaderModifier Shader Modifier value generated by generateVsFetchShaderBuildState(), use 0 if no fetch shader.
				 *  @param fetchShader If the shader requires a fetch shader, pass its GPU address here. Otherwise, pass NULL.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*fetchShader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setVsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setVsShader(const sce::Gnmx::VsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a VS shader to the VS stage without a fetch shader.
				 *  @param shader Pointer to the VS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setVsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				SCE_GNM_FORCE_INLINE void setVsShader(const sce::Gnmx::VsShader* shader, const InputResourceOffsets* table) { setVsShader(shader, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the VS shader stage. Use for late fetch shader binding or updating fetch shader.
				 *  @param shaderModified Shader Modifier value generated by generateVsFetchShaderBuildState().
				 *  @param fetchShader Pointer to the fetch shader.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*fetchShader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setVsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a PS shader to the PS stage.
				 *  @param shader Pointer to the PS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setPsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setPsShader(const sce::Gnmx::PsShader* shader, const InputResourceOffsets* table);


				/** @brief Binds a CS shader to the CS stage.
				 *  @param shader Pointer to the CS shader.
				 *  @param table Matching ShaderResourceOffsets table created by generateShaderResourceOffsetTable.
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c><i>*shader</i></c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDispatch() is called.
				 *  @note This function must be called first before any resource bindings calls. If setCsShader() is called again, all resource bindings for the stage will need to be re-bound.
				 */
				void setCsShader(const sce::Gnmx::CsShader* shader, const InputResourceOffsets* table);

				/** @brief Specifies a range of the Global Data Store to be used by shaders for atomic global counters such as those
				 *  used to implement PSSL <c>AppendRegularBuffer</c> and <c>ConsumeRegularBuffer</c> objects.
				 *
				 *  Each counter is a 32-bit integer. The counters for each shader stage may have a different offset in GDS. For example:
				 *  @code
				 *     setAppendConsumeCounterRange(kShaderStageVs, 0x0100, 12) // Set up 3 counters for the VS stage starting at offset 0x100.
				 *     setAppendConsumeCounterRange(kShaderStageCs, 0x0400, 4)  // Set up 1 counter for the CS stage at offset 0x400.
				 *	@endcode
				 *
				 *  The index is defined by the chosen slot in the PSSL shader. For example:
				 *  @code
				 *     AppendRegularBuffer<uint> appendBuf : register(u3) // Will access the 4th counter starting at the base offset provided to this function.
				 *  @endcode
				 *
				 *  This function never rolls the hardware context.
				 *
				 *  @param shaderStage The shader stage to bind this counter range to.
				 *  @param gdsMemoryBaseInBytes The byte offset to the start of the counters in GDS. Must be a multiple of 4.
				 *  @param countersSizeInBytes The size of the counter range in bytes. Must be a multiple of 4.
				 *  @note GDS accessible size is provided by sce::Gnm::kGdsAccessibleMemorySizeInBytes. 
				 */
				void setAppendConsumeCounterRange(sce::Gnm::ShaderStage shaderStage, uint32_t gdsMemoryBaseInBytes, uint32_t countersSizeInBytes);


				/** @brief Binds one or more constant buffer objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxConstantBufferCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setConstantBuffers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more vertex buffer objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxVertexBufferCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer The constant buffer objects to bind to the specified slots.
				 *	buffer[0] will be bound to <c><i>startApiSlot</i></c>, buffer[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setVertexBuffers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read-only buffer objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxResourceCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer The buffer objects to bind to the specified slots.
				 *	buffer[0] will be bound to <c><i>startApiSlot</i></c>, buffer[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note Buffers and Textures share the same pool of API slots.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setBuffers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read/write buffer objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxRwResourceCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param buffer The rwbuffer objects to bind to the specified slots.
				 *	buffer[0] will be bound to <c><i>startApiSlot</i></c>, buffer[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note rwBuffers and rwTextures share the same pool of API slots.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setRwBuffers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read-only texture objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxResourceCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param texture The texture objects to bind to the specified slots.
				 *	texture[0] will be bound to <c><i>startApiSlot</i></c>, texture[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note Buffers and Textures share the same pool of API slots.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setTextures(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Texture* texture);


				/** @brief Binds one or more read/write texture objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxRwResourceCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param texture The rwtexture objects to bind to the specified slots.
				 *	texture[0] will be bound to <c><i>startApiSlot</i></c>, texture[1] to <c><i>startApiSlot+1</i></c>, and so on.
				 *	The contents of these Buffer objects are cached locally inside the LCUE's scratch buffer.
				 *  @note rwBuffers and rwTextures share the same pool of API slots.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setRwTextures(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Texture* texture);


				/** @brief Binds one or more sampler objects to the specified shader stage.
				 *  @param shaderStage The resource(s) will be bound to this shader stage.
				 *  @param startApiSlot The first API slot to bind to. Valid slots are [0..LCUE::kMaxSamplerCount-1].
				 *  @param apiSlotCount The number of consecutive API slots to bind.
				 *  @param sampler The sampler objects to bind to the specified slots. 
				 *  sampler[0] will be bound to <c><i>startApiSlot</i></c>, sampler[1] to <c><i>startApiSlot+1</i></c>, and so on. 
				 *  The contents of these Sampler objects are cached locally inside the LCUE's scratch buffer.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setSamplers(sce::Gnm::ShaderStage shaderStage, int32_t startApiSlot, int32_t apiSlotCount, const sce::Gnm::Sampler* sampler);


				/** @brief Binds a user SRT buffer.
				 *  @param shaderStage The shader stage to bind the SRT buffer to.
				 *  @param buffer Pointer to the buffer. If NULL, <c><i>bufSizeInDwords</i></c> must be 0.
				 *  @param sizeInDwords Size of the data pointed to by <c><i>buffer</i></c> in dwords. Valid range is [1..kMaxSrtUserDataCount] if <c><i>buffer</i></c> is non-NULL.
				 *  @note This binding will not take effect on the GPU until preDraw() or preDispatch() is called.
				 */
				void setUserSrtBuffer(sce::Gnm::ShaderStage shaderStage, const void* buffer, uint32_t sizeInDwords);


				//////////// Draw commands

				/** @brief Inserts a draw call using auto generated indices.
				 *  Will roll context if previous draw was a dispatchDraw() as related context state must be restored.
				 *  In addition, as draw commands use the current context, a context roll will result from the next command which sets context state.
				 *  @param indexCount Indices are auto generated up to <c><i>indexCount</i></c>.
				 *  @see Gnm::DrawCommandBuffer::setPrimitiveType
				 */
				SCE_GNM_FORCE_INLINE void drawIndexAuto(uint32_t indexCount)
				{
					preDraw();
					m_dcb->drawIndexAuto(indexCount);
				}


				/** @brief Inserts a draw call using provided indices which are inserted into the command buffer.
				 *	Will roll context if previous draw was a dispatchDraw() as related context state must be restored.
				 *	In addition, as draw commands use the current context, a context roll will result from the next command which sets context state.
				 *  @param indexCount  Number of indices to insert.
				 *  @param indices     Pointer to first index in buffer containing <c><i>indexCount</i></c> indices. Pointer should be 4-byte aligned.
				 *  @param indicesSizeInBytes Size of the buffer pointed to by <c><i>indices</i></c> (in bytes). To specify the size of individual indices, use setIndexSize().
				 *  @see Gnm::DrawCommandBuffer::setPrimitiveType, Gnm::DrawCommandBuffer::setIndexSize
				 */
				SCE_GNM_FORCE_INLINE void drawIndexInline(uint32_t indexCount, const void *indices, uint32_t indicesSizeInBytes)
				{
					preDraw();
					m_dcb->drawIndexInline(indexCount, indices, indicesSizeInBytes);
				}


				/** @brief Inserts a draw call using indices which are located in memory.
				 *	Will roll context if previous draw was a dispatchDraw() as related context state must be restored.
				 *  In addition, as draw commands use the current context, a context roll will result from the next command which sets context state.
				 *  @param indexCount  Number of indices to insert.
			     *  @param indexAddr   GPU address of index buffer.
			     *  @see Gnm::DrawCommandBuffer::setPrimitiveType, Gnm::DrawCommandBuffer::setIndexSize
			     */
				SCE_GNM_FORCE_INLINE void drawIndex(uint32_t indexCount, const void *indexAddr)
				{
					preDraw();
					m_dcb->drawIndex(indexCount, indexAddr);
				}


				/** @brief Inserts a draw call using indices which are located in memory, whose base, size, and element size were set previously.
				 * 	Will roll context if previous draw was a dispatchDraw, as related context state must be restored.
				 *	In addition, as draw commands use the current context, a context roll will result from the next command which sets context state.
				 *	@param indexOffset Starting index number in the index buffer.
				 *	@param indexCount  Number of indices to insert.
				 *	@see Gnm::DrawCommandBuffer::setIndexBuffer, Gnm::DrawCommandBuffer::setIndexCount, Gnm::DrawCommandBuffer::setIndexSize
				 */
				SCE_GNM_FORCE_INLINE void drawIndexOffset(uint32_t indexOffset, uint32_t indexCount)
				{
					preDraw();
					m_dcb->drawIndexOffset(indexOffset, indexCount);
				}


				/** @brief Issues an indirect draw call, which reads its parameters from a specified address in GPU memory.
				 *	Will roll context if previous draw was a dispatchDraw() as related context state must be restored.
				 *	In addition, as draw commands use the current context, a context roll will result from the next command which sets context state.
				 *	@param dataOffsetInBytes Offset (in bytes) into the buffer that contains the indirect arguments, set using setBaseIndirectArgs().
				 *	The data at this offset should be a Gnm::DrawIndirectArgs structure.
				 *	@note The buffer containing the indirect arguments should already have been set using setBaseIndirectArgs().
				 *	@see Gnm::DrawIndexIndirectArgs, setBaseIndirectArgs
				 */
				SCE_GNM_FORCE_INLINE void drawIndirect(uint32_t dataOffsetInBytes)
				{
					preDraw();
					m_dcb->drawIndirect(dataOffsetInBytes);
				}


				/** @brief Issues an indirect draw call, which reads its parameters from a specified address in GPU memory.
				 *	Will roll context if previous draw was a dispatchDraw() as related context state must be restored.
				 *	In addition, as draw commands use the current context, a context roll will result from the next command which sets context state.
				 *	@param dataOffsetInBytes Offset (in bytes) into the buffer that contains the indirect arguments, set using setBaseIndirectArgs().
				 *  The data at this offset should be a Gnm::DrawIndexIndirectArgs structure.
				 *	@note The index buffer and the buffer containing the indirect arguments should already have been set up using setIndexBuffer() and setIndexCount().
				 *	@see Gnm::DrawIndexIndirectArgs, setBaseIndirectArgs, setIndexBuffer, setIndexCount
				 */
				SCE_GNM_FORCE_INLINE void drawIndexIndirect(uint32_t dataOffsetInBytes)
				{
					preDraw();
					m_dcb->drawIndexIndirect(dataOffsetInBytes);
				}


				////////////// Dispatch commands

				/** @brief Inserts a compute shader dispatch with the indicated number of thread groups.
				 * 	This function never rolls the hardware context.
				 *	@param threadGroupX Number of thread groups dispatched along the X dimension.
				 *	@param threadGroupY Number of thread groups dispatched along the Y dimension.
				 *	@param threadGroupZ Number of thread groups dispatched along the Z dimension.
				 */
				SCE_GNM_FORCE_INLINE void dispatch(uint32_t threadGroupX, uint32_t threadGroupY, uint32_t threadGroupZ)
				{
					preDispatch();
					m_dcb->dispatch(threadGroupX, threadGroupY, threadGroupZ);
				}


				/** @brief Inserts an indirect compute shader dispatch, whose parameters are read from GPU memory.
				 *  This function never rolls the hardware context.
				 *  @param dataOffsetInBytes Offset (in bytes) into the buffer that contains the indirect arguments (set using <c>setBaseIndirectArgs()</c>).
				 *	The data at this offset should be a Gnm::DispatchIndirectArgs structure.
				 *  @note The buffer containing the indirect arguments should already have been set using <c>setBaseIndirectArgs()</c>.
				 *  @see Gnm::DispatchCommandBuffer::setBaseIndirectArgs
				 */
				SCE_GNM_FORCE_INLINE void dispatchIndirect(uint32_t dataOffsetInBytes)
				{
					preDispatch();
					m_dcb->dispatchIndirect(dataOffsetInBytes);
				}

				
				/** @brief Executes all previous enqueued resource and shader bindings in preparation for a draw call.
				 *  Dirty resource bindings will be flushed from the internal scratch buffer, and committed to the resource buffer
				 *  @note When using the Lightweight Constant Update Engine to manage shaders and shader resources, this function must be called 
				 *  immediately before every draw call
				 */
				void preDraw();

				
				/** @brief Executes all previous enqueued resource and shader bindings in preparation for a dispatch call.
				 *  Dirty resource bindings will be flushed from the internal scratch buffer, and committed to the resource buffer
				 *  @note When using the Lightweight Constant Update Engine to manage shaders and shader resources, this function must be called 
				 *  immediately before every draw call
				 */
				void preDispatch();

	#if !defined(DOXYGEN_IGNORE)

				SCE_GNM_LCUE_NOT_SUPPORTED
				void setInternalSrtBuffer(sce::Gnm::ShaderStage shaderStage, const void* buffer){};

			protected:

				uint32_t						m_scratchBuffer[kGraphicsScratchBufferSizeInDwords];
				sce::Gnm::DrawCommandBuffer*	m_dcb;
				Gnm::ActiveShaderStages			m_activeShaderStages;

				// Each active shader stage has a pointer to inside the buffer where it should place its resources according to the offset table
				const void*			m_boundShader[sce::Gnm::kShaderStageCount];
				uint32_t			m_boundShaderAppendConsumeCounterRange[sce::Gnm::kShaderStageCount];
				const void*			m_boundFetchShader[sce::Gnm::kShaderStageCount];	// LS, ES or VS
				uint32_t			m_boundShaderModifier[sce::Gnm::kShaderStageCount]; // LS, ES or VS
				const InputResourceOffsets* m_boundShaderResourceOffsets[sce::Gnm::kShaderStageCount];
				
				bool m_dirtyShader[sce::Gnm::kShaderStageCount];
				bool m_dirtyShaderResources[sce::Gnm::kShaderStageCount];
		
				// Geometry Shader - Only used if LCUE_GEOMETRY_SHADERS_ENABLED is defined
				InputResourceOffsets m_fixedGsVsShaderResourceOffsets;				// Fixed offset table for the VS GPU stage when the Geometry pipeline is enabled (the copy shader)
				InputResourceOffsets m_fixedGsVsStreamOutShaderResourceOffsets;		// Fixed offset table for the VS GPU stage when the Geometry pipeline is enabled (the copy shader)
				Gnm::GsMode m_gsMode;												// Last tracked GsMode
				Gnm::GsMaxOutputVertexCount m_gsMaxOutput;							// Last tracked GsMaxOutputVertexCount

				// Tessellation
				uint32_t	m_tessellationCurrentTgPatchCount;
				Gnm::Buffer m_tessellationCurrentCb;
				bool		m_tessellationAutoManageReservedCb;

				mutable ShaderResourceBindingValidation m_boundShaderResourcesValidation[sce::Gnm::kShaderStageCount];

			private:

				SCE_GNM_FORCE_INLINE uint32_t* flushScratchBuffer(sce::Gnm::ShaderStage shaderStage);
				SCE_GNM_FORCE_INLINE void updateLsEsVsPtrsInUserDataSgprs(sce::Gnm::ShaderStage shaderStage, const uint32_t* resourceBufferFlushedAddress);
				SCE_GNM_FORCE_INLINE void updateCommonPtrsInUserDataSgprs(sce::Gnm::ShaderStage shaderStage, const uint32_t* resourceBufferFlushedAddress);
				SCE_GNM_FORCE_INLINE void updateEmbeddedCb(sce::Gnm::ShaderStage shaderStage, const sce::Gnmx::ShaderCommonData* shaderCommon);
				
				void preDrawTessellation(bool geometryShaderEnabled);
				void preDrawGeometryShader();

				void setUserData(sce::Gnm::ShaderStage shaderStage, int32_t startSgpr, int32_t sgprCount, const uint32_t* data);
				void setPtrInUserData(sce::Gnm::ShaderStage shaderStage, int32_t startSgpr, const void* gpuAddress);
	#endif // !defined(DOXYGEN_IGNORE)
			};


			/** @brief Encapsulates a Gnm::DrawCommandBuffer and Lightweight ConstantUpdateEngine (LCUE) and wraps them in a single higher-level interface.
			 *  This can be used as a main entry point into the PlayStation®4 rendering API, or can be used in conjunction with the Gnmx::GfxContext 
			 *  see cue_to_lcue.h for an example.
			 *  
			 *  Only functions that are overridden by the LCUE will be documented here. For information on other GraphicsContext functions, please
			 *  see the Gnmx::GfxContext reference.
			 */
			class SCE_GNMX_EXPORT GraphicsContext : public GraphicsConstantUpdateEngine
			{
			public:

				/** @brief Initializes a GraphicsContext with application-provided memory buffers for the LCUE.
				 *  @param dcbBuffer A buffer for use by the Draw Command Buffer.
				 *  @param dcbBufferSizeInDwords The size of <c><i>dcbBuffer</i></c>, in DWORDS.
				 *  @param resourceBufferInGarlic A resource buffer for use by the LCUE.
				 *  @param resourceBufferSizeInDwords The size of <c><i>resourceBufferInGarlic</i></c>, in DWORDS.
				 *  @param globalInternalResourceTableAddr A pointer to the global resource table in memory.
				 *  @param callbackFunc The callback to use when the dispatch command buffer (dcb) runs out of space for new commands.
				 *  @param callbackUserData User data to pass to <c><i>callbackFunc</i></c>.
				 */
				void init(uint32_t* dcbBuffer, int32_t dcbBufferSizeInDwords, uint32_t* resourceBufferInGarlic, int32_t resourceBufferSizeInDwords, 
						  uint32_t* globalInternalResourceTableAddr, sce::Gnm::CommandCallbackFunc callbackFunc, void *callbackUserData);


				/** @brief LCUE wrapper to sets the active shader stages in the graphics pipeline.
			 	 *	Note that the compute-only CS stage is always active.
			 	 *	This function will roll the hardware context.
				 *	@param activeStages Indicates which shader stages should be activated.
				 *  @note setGsMode will be automatically set by the LCUE
				 *	@cmdsize 3
				 */
				void setActiveShaderStages(Gnm::ActiveShaderStages activeStages)
				{
					GraphicsConstantUpdateEngine::setActiveShaderStages(activeStages);
					return m_dcb.setActiveShaderStages(activeStages);
				}


				
				/** @brief Sets the ring buffer where data will flow from the ES to the GS stages when geometry shading is enabled.
				 *  This function will roll hardware context.
				 *  @note This function modifies the global resource table. It is not safe to modify the global resource table unless the GPU graphics pipe is idle.
				 *  @param ringBuffer The address of the buffer.
				 *  @param ringSizeInBytes The size of the buffer in bytes.
				 *  @param maxExportVertexSizeInDword The maximum size of a vertex export in dwords.
				 */
				void setEsGsRingBuffer(void* ringBuffer, uint32_t ringSizeInBytes, uint32_t maxExportVertexSizeInDword);


				
				/** @brief Sets the ring buffers where data will flow from the GS to the VS stages when geometry shading is enabled.
				 *  This function will roll hardware context.
				 *  @note This function modifies the global resource table. It is not safe to modify the global resource table unless the GPU graphics pipe is idle.
				 *  @param ringBuffer The address of the buffer.
				 *  @param ringSize The size of the buffer in bytes.
				 *  @param vtxSizePerStreamInDword The vertex size for each of four streams in dwords.
				 *  @param maxOutputVtxCount The maximum number of vertices output from the GS stage.
				 */
				void setGsVsRingBuffers(void* ringBuffer, uint32_t ringSizeInBytes, const uint32_t vertexSizePerStreamInDword[4], uint32_t maxOutputVertexCount);
				
				// method forwarding to m_dcb 
				#include "lwgfxcontext_methods.h"

			public:
				sce::Gnm::DrawCommandBuffer m_dcb; ///< Draw command buffer. Access directly at your own risk!
				sce::Gnm::DispatchCommandBuffer m_acb; ///< Asynchronous compute dispatch command buffer. (Not used by the LCUE)
			};

		} // LightweightConstantUpdateEngine
	} // Gnmx
} // sce


#endif // _SCE_GNMX_LWGFXCONSTANTUPDATEENGINE_H