//
// atl/map.cpp
//
// Copyright (C) 1999-2006 Rockstar Games.  All Rights Reserved.
//

#include "map.h"

#include "qa/qa.h"

namespace rage {

#if ENABLE_PRIME_DEBUG
size_t g_primeOverhead = 0;
size_t g_primeWastedOverhead = 0;

void IncrementSlots(unsigned short slots, size_t entrySize)
{
	const size_t slotSize = entrySize * slots;

	const size_t nextPrime = GetNextPrime(slots);
	const size_t nextPrimeSize = entrySize * nextPrime;
	g_primeOverhead += (nextPrimeSize - slotSize);

	const size_t defaultPrime = atHashNextSize(slots);
	const size_t defaultPrimeSize = entrySize * defaultPrime;
	g_primeWastedOverhead += (defaultPrimeSize - nextPrimeSize);

	if (defaultPrimeSize > nextPrimeSize)
	{
		Displayf("%d,,,%d,%d,%d,,,%d,%d,%d", entrySize, slots, nextPrime, defaultPrime, slotSize, nextPrimeSize, defaultPrimeSize);
	}
}
#endif

// PURPOSE: Given a particular prime number, return the next one in the sequence.
// PARAMS: s - A prime number (our sequence starts at eleven)
// RETURNS: A prime number larger than s.
unsigned short atHashNextSize(unsigned short s) {
	// these are all primes.
	if (s < 11) return 11;
	else if (s < 29) return 29;
	else if (s < 59) return 59;
	else if (s < 107) return 107;
	else if (s < 191) return 191;
	else if (s < 331) return 331;
	else if (s < 563) return 563;
	else if (s < 953) return 953;
	else if (s < 1609) return 1609;
	else if (s < 2729) return 2729;
	else if (s < 4621) return 4621;
	else if (s < 7841) return 7841;
	else if (s < 13297) return 13297;
	else if (s < 22571) return 22571;
	else if (s < 38351) return 38351;
	else if (s < 65167) return 65167;
	else if (s <= 65521) return 65521; // ATL_MAP_MAX_SIZE
	Assertf(0,"invalid size %u in atHashNextSize", s);
	return 0;
}



unsigned atHash_const_char(const char *s) {

	// WARNING:
	// Implementation of atHash_const_char must not change, for reasons of backwards compatibility
	// Hash values generated by this function have been stored in various intermediate files

	unsigned h = 0, g;

	FastAssert(s);

	if (!s)
		return 0;

	// stolen from data/hash, presumably whoever wrote
	// this knew what they were doing.
	while (*s) {
		h=(h<<4)+(*s++);
		if (((g=h&0xf0000000)) != 0) {
			h=h^(g>>24);
			h=h^g;
		}
	}
	return h;
}

unsigned atHash_const_charU(const char *s) {

	// WARNING:
	// Implementation of atHash_const_charU must not change, for reasons of backwards compatibility
	// Hash values generated by this function have been stored in various intermediate files

	unsigned h = 0, g;

	// stolen from data/hash, presumably whoever wrote
	// this knew what they were doing.
	while (*s) {
		char c = *s++;
		if( c >= 'a' && c <= 'z' )
			c -= 0x20;

		h=(h<<4)+c;
		if (((g=h&0xf0000000)) != 0) {
			h=h^(g>>24);
			h=h^g;
		}
	}
	return h;
}

// To Do: need to come up with some 64 bit hashing algorithm
unsigned atHash64(u64 key) {
	unsigned h = 0, g;


	// stolen from data/hash, presumably whoever wrote
	// this knew what they were doing.
	// I have just ported over the above string handling code


	u32 count = 8;
	while (--count) {
		char s = (char) key;		// take the bottom 8 bits
		key = key >> 8;

		h=(h<<4)+s;
		if (((g=h&0xf0000000)) != 0) {
			h=h^(g>>24);
			h=h^g;
		}
	}

	return h;
}


}	// namespace rage

#if __QA

using namespace rage;

class atMapQa : public qaItem
{
public:
	void Init(int runSize);
	void Shutdown();

	void Update(qaResult& result);

private:
	int MakeKeyAndData(int i, char* data);
	int m_RunSize;
	atMap<int, const char*> m_Map;
};

void atMapQa::Init(int runSize)
{
	m_RunSize = runSize;

	for (int i = 0; i < m_RunSize; ++i)
	{
		char* data = rage_new char[20];
		int key = MakeKeyAndData(i, data);
		m_Map.Insert(key, data);	
	}
}

void atMapQa::Shutdown()
{
	atMap<int, const char*>::Iterator entry = m_Map.CreateIterator();
	for (entry.Start(); !entry.AtEnd(); entry.Next())
	{
		delete entry.GetData();
	}
}

void atMapQa::Update(qaResult& result)
{
	char data[20];

	for (int i = 0; i < m_RunSize; ++i)
	{
		int key = MakeKeyAndData(i, data);

		if(strcmp(*m_Map.Access(key), data) != 0)
		{
			TST_FAIL;
			return;
		}
	}

	TST_PASS;
}

int atMapQa::MakeKeyAndData(int i, char* data)
{
	// This is doing the same thing as mthRandom, so I don't have to depend on math
	int key = (((i = i * 214013L + 2531011L) >> 16) & 0x7fff);

	for (int j = 0; j < 19; ++j)
	{
		int randChar = (((i = i * 214013L + 2531011L) >> 16) & 0x7fff);
		data[j] = static_cast<char>((randChar%('Z' - 'A' + 1)) + 'A');
	}

	data[19] = '\0';

	return key;
}

QA_ITEM_FAMILY(atMapQa, (int runSize), (runSize));

QA_ITEM(atMapQa, (100), qaResult::FAIL_OR_TOTAL_TIME);
QA_ITEM(atMapQa, (1000), qaResult::FAIL_OR_TOTAL_TIME);
QA_ITEM(atMapQa, (10000), qaResult::FAIL_OR_TOTAL_TIME);

#endif // __QA
