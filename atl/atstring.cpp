//
// atl/string.cpp
//
// Copyright (C) 1999-2018 Rockstar Games.  All Rights Reserved.
//

#include "string.h"
#include "math/amath.h"
#include "profile/profiler.h"
#include "profile/rocky.h"

namespace rage {

IMPLEMENT_PLACE(atString);

unsigned atHash(const char *s) {
	extern unsigned atHash_const_char(const char*);
	return atHash_const_char(s);
}

unsigned short atHash16(const char *s)
{
	// WARNING:
	// Implementation of atHash16 must not change, for reasons of backwards compatibility
	// Hash values generated by this function have been stored in various intermediate files

	extern unsigned atHash_const_char(const char*);

	u32 hash = atHash_const_char(s);
	u32 prime = 65167;
	return u16((hash % prime) + (0xffff - prime));
}

unsigned short atHash16U(const char *s)
{
	// WARNING:
	// Implementation of atHash16 must not change, for reasons of backwards compatibility
	// Hash values generated by this function have been stored in various intermediate files

	extern unsigned atHash_const_charU(const char*);

	u32 hash = atHash_const_charU(s);
	u32 prime = 65167;
	return u16((hash % prime) + (0xffff - prime));
}

#if __ASSERT
unsigned short atValidateHash16U(const char *s,unsigned short hash,const char *file,int line)
{
	unsigned short check = atHash16U(s);
	Assertf(check == hash,"%s(%d): ATHASH16U(%s,0x%x) macro out of date, second parameter should be 0x%x",file,line,s,hash,check);
	return check;
}
#endif

unsigned short atHash15U(const char* name)
{
	// WARNING:
	// Implementation of atHash15U must not change, for reasons of backwards compatibility
	// Hash values generated by this function have been stored in various intermediate files

	extern unsigned atHash_const_charU(const char*);

	u32 hash = atHash_const_charU(name);
	u32 prime = 32749;
	return u16((hash % prime) + (0x7fff - prime));
}

void atString::_Append(const char* psz, int nLen)
{
	if (nLen == 0)
	{
		return;
	}

	int newlen = m_Length + nLen + 1;

	if (newlen > m_Allocated)
	{
		StringAssert(newlen <= 65535);
		char *ns = rage_new char[newlen];

		// Copy only the length of the "valid" string into the new buffer
		if (m_Data)
			memcpy(ns, m_Data, m_Length);

		m_Allocated = (unsigned short) newlen;

		delete[] m_Data;
		m_Data = ns;
	}

	memmove(m_Data + m_Length, psz, nLen);
	m_Data[m_Length + nLen] = 0;
	m_Length = (unsigned short) (m_Length + nLen);
}

void atString::_Append(const unsigned short* psz)
{
	if (!psz)
	{
		return;
	}

	int nLen = 0;
	while (psz[nLen])
		++nLen;

	if (nLen == 0)
	{
		return;
	}

	int newlen = m_Length + nLen + 1;

	if (newlen > m_Allocated)
	{
		StringAssert(newlen <= 65535);
		char *ns = rage_new char[newlen];

		// Copy only the length of the "valid" string into the new buffer
		if (m_Data)
			memcpy(ns, m_Data, m_Length);

		m_Allocated = (unsigned short) newlen;

		delete[] m_Data;
		m_Data = ns;
	}

	char *d = m_Data + m_Length;
	while (*psz)
		*d++ = (char)*psz++;
	m_Data[m_Length + nLen] = 0;
	m_Length = (unsigned short) (m_Length + nLen);
}

void atString::Reserve(unsigned short bytes)
{
	Assert(m_Data == NULL && m_Length == 0 && m_Allocated == 0);	
	if (bytes == 0)
	{
		return;
	}

	// prevent memory leak
	if(m_Data != NULL)
	{
		return;
	}

	m_Data = rage_new char[bytes];
	m_Allocated = bytes;
}

void atString::Resize(unsigned short bytes)
{
	if (bytes == m_Allocated)
	{
		return;
	}

	StringAssert(bytes <= 65535);

	char *newData = rage_new char[bytes];
	if (m_Data != nullptr) 
	{
		unsigned short len = (bytes<m_Allocated)?bytes:m_Allocated;
		memcpy(newData,m_Data,len);
	}

	delete[] m_Data;
	m_Allocated = bytes;
	if (m_Length>=bytes)
	{
		m_Length = bytes - 1;
		newData[m_Length] = 0;
	}
	m_Data = newData;
}

void atString::Set(const atString &str,int firstChar,int length) {
	Assert(firstChar >= 0 && firstChar <= str.GetLength());
	if (length == npos || length > (str.GetLength() - firstChar))
		length = str.GetLength() - firstChar;
	m_Length = 0;
	_Append(str.m_Data + firstChar,length);
}

void atString::Set(const char *str, int strLength, int firstChar, int length /* = npos */) {
	Assert(firstChar >= 0 && firstChar <= strLength);
	if(npos == length || length > (strLength - firstChar))
		length = strLength - firstChar;
	m_Length = 0;
	_Append(str + firstChar, length);
}

void atString::Lowercase()
{
    if (m_Length) {
        for (char* c=m_Data; *c; c++) {
            if (*c >= 'A' && *c <= 'Z')
                *c += 32;
        }
    }
}

void atString::Uppercase()
{
    if (m_Length) {
        for (char* c=m_Data; *c; c++) {
            if (*c >= 'a' && *c <= 'z')
                *c -= 32;
        }
    }
}

bool atString::EndsWith(const char* str) const 
{
    int length=(int)strlen(str);
    if (length>m_Length)
        return false;

    char* data=m_Data+(m_Length-length);
    for (int i=length-1;i>=0;i--)
    {
        if (data[i]!=str[i])
            return false;
    }

    return true;
}

bool atString::StartsWith(const char* str) const 
{
    int length=(int)strlen(str);
    if (length>m_Length)
        return false;

    for (int i=0;i<length;i++)
    {
        if (m_Data[i]!=str[i])
            return false;
    }

    return true;
}

int atString::IndexOf( char c, int startIndex ) const
{
    if ( startIndex == npos )
        startIndex = 0;

    for (int i=startIndex;i<m_Length;i++)
    {
        if (m_Data[i]==c)
            return i;
    }

    return npos;
}

int atString::IndexOf( const char* str, int startIndex ) const
{
    if ( startIndex == npos )
        startIndex = 0;

    if ( startIndex >= m_Length )
        return npos;

    const char *p = strstr( &(m_Data[startIndex]), str );
    if ( p != NULL )
        return (int)(p - m_Data);

    return npos;
}

int atString::LastIndexOf( char c ) const
{
    for (int i=m_Length-1;i>=0;i--)
    {
        if (m_Data[i]==c)
            return i;
    }

    return npos;
}

int atString::LastIndexOf( const char* str ) const
{
    const char *pLast = NULL;
    const char *p = strstr( m_Data, str );
    while ( p && (p < m_Data + m_Length) )
    {
        pLast = p;

        if ( pLast + 1 < m_Data + m_Length )
        {
            p = strstr( pLast + 1, str );
        }
        else
        {
            break;
        }
    }

    if ( pLast != NULL )
        return (int)(pLast - m_Data);

    return npos;
}

void atString::ReplaceSubstring(int startPos, int numChars, const char* other, const int otherLen)
{
	PROFILE

	if (m_Data == 0)
		return; // I am an empty string, there's nothing to replace

	if (startPos < 0 || startPos + numChars > m_Length)
		return; // out of range

	// calculate the new length of the string
	unsigned short newLength = (unsigned short)(m_Length - numChars + otherLen);

	// calculate the difference in length
	int sizeDiff = otherLen - numChars;

	// if we are growing...
	if (sizeDiff > 0)
	{
		// preallocate space for the new string
		Resize(newLength + 1 /* null term */);

		// Shift the remainder of the string to the end of our newly sized string
		for (int i = newLength - 1; i >= startPos + sizeDiff; i--)
		{
			m_Data[i] = m_Data[i-sizeDiff];
		}
	}
	// if we are shrinking...
	else if (sizeDiff < 0)
	{	
		// shift our string to the left to replace the text we're losing
		for (int i = startPos; i < m_Length + sizeDiff; i++)
		{
			m_Data[i] = m_Data[i - sizeDiff];
		}

		// resize the string to our reduced length
		Resize(newLength + 1 /* null term */);
	}

	// Copy the other string into our substring.
	for (int i = 0, j = startPos; i < otherLen; i++, j++)
	{
		m_Data[j] = other[i];
	}

	// recalculate length
	m_Length = newLength;

	// null terminate
	m_Data[m_Length] = 0;
}

void atString::Replace( const char *search, const char *replace )
{
	PROFILE

	if (m_Data == 0)
		return; // I am an empty string, there's nothing to replace

	if ((search[0]|replace[0]) == 0)
		return; // nothing to do - otherwise this will crash

	const char *p = strstr( m_Data, search );
	if ( p == nullptr )
		return; //no match to replace

	atString old(*this);

	// 1st pass: build cache and get length of the new string	
	int lenSearch = (int)strlen(search);
	const int maxFinds = 16;
	unsigned int findCache[maxFinds];
	unsigned int findCacheIdx = 0;
			
	while ( p != nullptr )
	{
		if (findCacheIdx==maxFinds)
		{
			// recurse if needed (more than maxFinds occurrences)
			//const char* tmpRemainderStr = p + lenSearch;
			atString tmpRemainder;
			tmpRemainder.Set(*this, findCache[findCacheIdx-1] + lenSearch);
			unsigned tmpLen = tmpRemainder.length();
			tmpRemainder.Replace(search, replace);
			
			// copy the result of the recursion back into the original string
			if (tmpLen<tmpRemainder.length())
			{
				old.Resize((unsigned short)(old.length() + tmpRemainder.length() - tmpLen));
			}
			memcpy(old.m_Data + findCache[maxFinds-1] + lenSearch, tmpRemainder.m_Data, tmpRemainder.length());

			break; // EXIT while ( p != nullptr )
		}

		findCache[findCacheIdx++] = (unsigned int)(p - m_Data);
		p = strstr(p + lenSearch, search);
	}

	// prepare buffer for replacement operations - this might mean we knowingly "underuse" the buffer
	int lenReplace = (int)strlen(replace);
	int lenTarget = m_Length + findCacheIdx * (lenReplace - lenSearch) + 1  /* null term */;
	StringAssert(lenTarget<65536);
	if (m_Allocated<lenTarget)
	{
		Resize((unsigned short)lenTarget);
	}
		
	m_Length = (unsigned short)(lenTarget - 1);

	// 2nd run - copy the string into place - prevent loop if not needed
	unsigned int posOld = 0;
	unsigned int posNew = 0;
	if (findCacheIdx > 1)
	{
 		for (int ii=0;ii < (int)findCacheIdx; ++ii)
		{
			unsigned int idx = findCache[ii];
			memcpy(m_Data + posNew, old.m_Data + posOld, idx-posOld);
			posOld = idx + lenSearch;
			posNew = idx + ii * (lenReplace - lenSearch);
			memcpy(m_Data + posNew, replace, lenReplace);
			posNew += lenReplace;
		}
	}
	else
	{
		unsigned int idx = findCache[0];
		memcpy(m_Data, old.m_Data, idx);
		posOld = idx + lenSearch;
		posNew = idx;
		memcpy(m_Data + posNew, replace, lenReplace);
		posNew += lenReplace;
	}
	unsigned short remainder = (unsigned short)(old.m_Length-posOld);
	memcpy(m_Data + posNew, old.m_Data + posOld, remainder);
	m_Data[m_Length] = '\0';
}

void atString::Split( atString& left, atString& right, char c ) const
{
    int pos = IndexOf( c );
    if ( pos == npos )
    {
        left = *this;
        right = "";
    } 
    else if ( pos == 0 )
    {
        left = "";
        right.Set( *this, 1 );
    }
    else
    {
        left.Set( *this, 0, pos );
        right.Set( *this, pos + 1 );
    }
}

void atString::Split( atString& left, atString& right, const char* s ) const
{
    int pos = IndexOf( s );
    if ( pos == npos )
    {
        left = *this;
        right = "";
    } 
    else if ( pos == 0 )
    {
        left = "";
        right.Set( *this, 1 );
    }
    else
    {
        left.Set( *this, 0, pos );
        right.Set( *this, pos + (int)strlen( s ) );
    }
}

void atString::Split( atArray<atString> &split, char c, bool removeEmptyStrings ) const
{   
    int startIndex = 0;
    int indexOf = IndexOf( c );
    while ( indexOf != npos )
    {
        if ( indexOf == startIndex )
        {
            if ( !removeEmptyStrings )
            {
                split.Grow() = "";
            }                

            startIndex = indexOf + 1;
            indexOf = IndexOf( c, startIndex );
            continue;
        }

        atString temp;
        temp.Set( *this, startIndex, indexOf - startIndex );

        if ( removeEmptyStrings )
        {
            atString trim( temp );
            trim.Trim();

            if ( trim.GetLength() > 0 )
            {
                split.Grow() = temp;
            }
        }
        else
        {
            split.Grow() = temp;
        }

        startIndex = indexOf + 1;
        indexOf = IndexOf( c, startIndex );
    }

    if ( startIndex <= m_Length )
    {
        atString temp;
        temp.Set( m_Data, m_Length, startIndex );

        if ( removeEmptyStrings )
        {
            atString trim( temp );
            trim.Trim();

            if ( trim.GetLength() > 0 )
            {
                split.Grow() = temp;
            }
        }
        else
        {
            split.Grow() = temp;
        }
    }
}

void atString::Split( atArray<atString> &split, const char* str, bool removeEmptyStrings ) const
{
    int length = (int)strlen( str );

    int startIndex = 0;
    int indexOf = IndexOf( str );
    while ( indexOf != npos )
    {
        if ( indexOf == startIndex )
        {
            if ( !removeEmptyStrings )
            {
                split.Grow() = "";
            }                

            startIndex = indexOf + length;
            indexOf = IndexOf( str, startIndex );
            continue;
        }

        atString temp;
        temp.Set( *this, startIndex, indexOf - startIndex );

        if ( removeEmptyStrings )
        {
            atString trim( temp );
            trim.Trim();

            if ( trim.GetLength() > 0 )
            {
                split.Grow() = temp;
            }
        }
        else
        {
            split.Grow() = temp;
        }

        startIndex = indexOf + length;
        indexOf = IndexOf( str, startIndex );
    }

    if ( startIndex <= m_Length )
    {
        atString temp;
        temp.Set( m_Data, m_Length, startIndex );

        if ( removeEmptyStrings )
        {
            atString trim( temp );
            trim.Trim();

            if ( trim.GetLength() > 0 )
            {
                split.Grow() = temp;
            }
        }
        else
        {
            split.Grow() = temp;
        }
    }
}

void atString::Append(const char* str, int length)
{
	if (length == -1)
	{
		_Append(str, istrlen(str));
	}
	else
	{
		_Append(str, length);
	}
}

void atString::Append(int count, char c)
{
	if (count == 0)
		return;

	// resize to fit the new characters
	Resize((unsigned short)(m_Length + count) + 1 /* null term */);

	// Append a series of 'c'
	for (int i = 0; i < count; i++)
	{
		_Append(&c, 1);
	}
}

void atString::TrimLeft()
{
    int const c_length = GetLength();
    int i;

    for( i = 0; i < c_length; ++i )
    {
        if ( !isspace( (unsigned char)m_Data[i] ) )
        {
            if ( i > 0 )
            {
                for ( int j = i; j < c_length; ++j )
                {
                    m_Data[j - i] = m_Data[j];
                }

                Truncate( c_length - i );
            }

            break;
        }
    }

    //! All characters were spaces, so just abandon and clear our string
    if( i == c_length )
    {
        Clear();
    }
}

void atString::TrimRight()
{
    int const c_length = GetLength();
    int i;

    for ( i = c_length - 1; i >= 0 ; --i )
    {
        if ( !isspace( (unsigned char)m_Data[i] ) )
        {
            if ( i < c_length - 1 )
            {
                Truncate( i + 1 );
            }

            break;
        }
    }

    //! All characters were spaces, so just abandon and clear our string
    if( i == npos )
    {
        Clear();
    }
}

void atString::Trim()
{
    TrimLeft();
    TrimRight();
}

atString atString::Join(const atArray<atString> & strs, int beginIdx, int endIdx, const char* separator/* ="" */)
{
	int realBeginIdx = beginIdx >= 0 ? beginIdx : strs.GetCount() + beginIdx;
	int realEndIdx = endIdx >= 0 ? endIdx : strs.GetCount() + endIdx;

	realBeginIdx = Clamp(realBeginIdx, 0, strs.GetCount()-1);
	realEndIdx = Clamp(realEndIdx, 0, strs.GetCount()-1);

	unsigned short bytes = 0;
	unsigned short sepBytes = (unsigned short)strlen(separator);
	for(int i = realBeginIdx; i <= realEndIdx; i++)
	{
		if (i != realBeginIdx)
		{
			bytes += sepBytes;
		}
		bytes += (unsigned short)strs[i].GetLength();
	}

	atString ret;
	ret.Reserve(bytes);
	for(int i = realBeginIdx; i <= realEndIdx; i++)
	{
		if (i != realBeginIdx)
		{
			ret += separator;
		}
		ret += strs[i];
	}
	return ret;
}

void atString::Erase(int startPos, int length, bool bResizeAfterErase)
{
	if (startPos == 0 && length == npos)
	{
		Clear();
		return;
	}

	// out of bounds
	if (startPos < 0 || startPos + length >= m_Length || length == 0)
		return;

	// copy the data after the string
	for (int i = startPos; i < m_Length - length; i++)
	{
		m_Data[i] = m_Data[i + length];
	}

	// decrease the length and add the null terminator
	m_Length -= (unsigned short)length;
	m_Data[m_Length] = 0;
	
	// if specified, resize the string after the operation.
	if (bResizeAfterErase)
	{
		Resize(m_Length + 1 /* null term */);
	}
}

void atString::Serialize(datSerialize& ser)
{
	if( ser.IsRead() )
	{
		int len;
		ser << len;

		if (len > m_Allocated) 
		{
			StringAssert(len <= 65535);
			char *ns = rage_new char[len];
			m_Allocated = (unsigned short) len;

			delete[] m_Data;
			m_Data = ns;
		}

		if (len > 0)
		{
			ser.Get( m_Data, len );
			m_Length = (unsigned short) len-1;	
		}
		else
		{
			m_Length = 0;
		}
	}
	else
	{
		int len = m_Length;

		if (len > 0)
		{
			len++;
			ser << len;
			ser.Put( m_Data );
		}
		else
		{
			ser << len;
		}
	}
}


#if __WIN32 || !defined(__WIN32)
#define SLASH		'\\'
#define OTHER_SLASH	'/'
#else
#define SLASH		'/'
#define OTHER_SLASH	'\\'
#endif

void atParsePathElements(const atString &src,atString &path,atString &basename,atString &ext) {
	int i = src.GetLength() - 1;
	bool gotExt = false;
	ext.Reset();

	while (i >= 0) {
		// If we hit a period, that's our extension
		if (src[i]=='.') {
			ext.Set(src,i+1);
			gotExt = true;
			break;
		}
		// Otherwise if we hit a path separator first, there is no extension
		else if ((src[i]==':'&&i==1)||src[i]=='/'||src[i]=='\\')
			break;
		--i;
	}

	int end = gotExt? i : src.GetLength();
	if (gotExt) {	// search for basename
		while (i >= 0) {
			if ((src[i]==':'&&i==1)||src[i]=='/'||src[i]=='\\')
				break;
			--i;
		}
	}

	basename.Set(src,i+1,end-i-1);
	path.Set(src,0,i+1);

	for (i=0; i<path.GetLength(); i++)
		if (path[i] == OTHER_SLASH)
			path[i] = SLASH;
}


void atParsePathElements(const atString &src,atString &path,atString &file) {
	int i = src.GetLength() - 1;

	while (i >= 0) {
		if ((src[i]==':'&&i==1)||src[i]=='/'||src[i]=='\\')
			break;
		--i;
	}

	file.Set(src,i+1);
	path.Set(src,0,i+1);

	for (i=0; i<path.GetLength(); i++)
		if (path[i] == OTHER_SLASH)
			path[i] = SLASH;
}

}
