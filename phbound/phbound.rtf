{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}
{\f63\froman\fcharset238\fprq2 Times New Roman CE;}{\f64\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f66\froman\fcharset161\fprq2 Times New Roman Greek;}{\f67\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f68\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f69\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f70\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f71\fswiss\fcharset238\fprq2 Arial CE;}{\f72\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f74\fswiss\fcharset161\fprq2 Arial Greek;}{\f75\fswiss\fcharset162\fprq2 Arial Tur;}{\f76\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f77\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f78\fswiss\fcharset186\fprq2 Arial Baltic;}
{\f79\fmodern\fcharset238\fprq1 Courier New CE;}{\f80\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f82\fmodern\fcharset161\fprq1 Courier New Greek;}{\f83\fmodern\fcharset162\fprq1 Courier New Tur;}{\f84\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f85\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f86\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;
\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\b\f1\fs32\lang1033\langfe1033\kerning32\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{\s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\b\i\f1\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 2;}{\s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
\sbasedon0 \snext0 heading 3;}{\s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive 
Default Paragraph Font;}}{\*\listtable{\list\listtemplateid223356894\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers
;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360
\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }
{\listname ;}\listid904295258}{\list\listtemplateid426790084\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr
\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693
\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext
\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360
\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1
\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0
\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040\jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23
\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }
{\listname ;}\listid1632519946}}{\*\listoverridetable{\listoverride\listid904295258\listoverridecount0\ls1}{\listoverride\listid1632519946\listoverridecount0\ls2}}{\info{\author sboswell}{\operator sboswell}{\creatim\yr2002\mo4\dy30\hr15\min14}
{\revtim\yr2002\mo5\dy10\hr15\min40}{\version24}{\edmins516}{\nofpages11}{\nofwords4241}{\nofchars24179}{\*\company Angel Studios}{\nofcharsws29693}{\vern8299}}
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1701\dgvorigin1984\dghshow1\dgvshow1
\jexpand\viewkind3\viewscale100\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd \linex0\endnhere\sectlinegrid360\sectdefaultcl {\*\pnseclvl1
\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 
\b\f1\fs32\lang1033\langfe1033\kerning32\cgrid\langnp1033\langfenp1033 {phBound
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
The phBound library contains classes that implement various types of bounding-shapes. All support collision-detection against each other, as well as probes (i.e. ray intersections).
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Overview
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Interface
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {The top-level interface for doing collision-detection is phSimulator::Collide(), and for test-probes it\rquote 
s phLevelSimple::TestProbe().
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phBoundGeometry
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phBoundGeometry will perform collision-detection and test-probes on geometric bounds. It\rquote 
s suited for small objects; for larger objects that need better performance (such as the game\rquote s maps and terrain), phBoundOctree is suggested.
\par There are two main modes of interaction with phBoundOctree: in the asset-building tool and in the game. In the game, interaction is taken care of by the physics manager.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {At tool time
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
phBoundGeometry is usually initialized by loading a bound file from disk, using Load(). (Alternately, one could use LoadAscii() or LoadBinary() to load a particular version of the bound.)
\par A phBoundOctree can also be built from scratch; call Init() with the total amount of vertices/materials/polygons/edges you expect to have, then call SetVertex()/SetMaterial()/SetPolygon() to fill in the details.
\par There are plenty of useful methods that can be called during construction. DecreaseNumPolys() will allow one to set a final number of polygons that\rquote 
s lower than the number passed to Init(). ConvertTrianglesToQuads() will find adjacent coplanar triangles that can be converted to quadrilaterals, and will do so. CombineBounds() will produce a new geometric bound
 that is the union of other geometric bounds.
\par When done loading or otherwise constructing, call PostLoadCompute() to calculate the edges, edge normals, and other necessary details of the phBoundGeometry.
\par When ready to save to disk, use Save() to write an asset file, or WriteResource() to write to a resource file.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phBoundOctree
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
phBoundGeometry will perform collision-detection and test-probes on geometric bounds, but it only works well for small objects. It\rquote s not really suited for the game\rquote s maps & terrain. p
hBoundOctree is a subclass of phBoundGeometry that adds a phStaticOctree, and uses it to partition the geometry into an octree.
\par There are two main modes of interaction with phBoundOctree: in the asset-building tool and in the game. In the game, interaction is taken care of by the physics manager.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {At tool time
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phBoundOctree\rquote s geometry is initialized in the same way that a phBoundGeometry is \endash 
 using Load(), or using Init() followed by the Set\'85() methods. Once the geometry is initialized, the octree is generated with InitOctree().
\par As with phBoundGeometry, when ready to save to disk, use Save() to write an asset file, or WriteResource() to write to a resource file.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Implementation
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phBoundGeometry
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {From its base class phBoundPolygonal, phBoundGeometry inherits Vec
tor3 *Vertices (an array of its vertices), phPolygon *Polygons (an array of the bound\rquote s polygons), and phHotEdge *Edges (an array of the bound\rquote 
s edges). To this, phBoundGeometry adds phMaterial **Materials (an array of pointers to material objects) and EdgeInfo *EdgeNormalInfo (an array of additional information about edges, indexed by edge-number like the Edges array).
\par The storage for all of these structures (except for edge-normals) is allocated in Init(); the storage for edge-normals is allocated in InitEdgeNormals().
\par 3-D game geometry is a pretty well-researched topic, and for those who understand it, phBoundGeometry\rquote s implementation is pretty straightforward.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phBoundOctree
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phBoundOctree is basically a phBoundGeometry (its base class) with a phStaticOctree member added to it.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phStaticOctree
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phStaticOctree is a typedef for phPolytree<phOctreeCell>. It\rquote 
s a static octree because it can only hold static geometry, i.e. it\rquote s not suited for containing geometry that\rquote ll change form or position at run time.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phPolytree
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phPolytree\rquote 
s implementation is pretty complex. The idea of a quadtree or an octree is simple enough, but phPolytree has many variations on the idea. Which variation you use depends on your particular performance requirements.
\par For one thing, the type of cell that phPolytree uses is abstract; it\rquote s a template parameter, called CellType. There are presently two classes that qualify to be the CellType, phOctreeCell and phQuadtreeCell.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Options
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {At the top of phPolytree.h are several compilation flags that turn
 on and off particular phPolytree features; 0 turns them off, 1 turns them on. They are:
\par 
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li720\ri0\widctlpar\jclisttab\tx720\aspalpha\aspnum\faauto\ls1\adjustright\rin0\lin720\itap0 {PT_STORE_BOX / PT_CALC_BOX\line }{
Each cell has a bounding box.  If PT_STORE_BOX is 1, the bounding box is stored in each cell, as two Vector3 objects.  If PT_CALC_BOX is 1,
 the bounding box for each cell is calculated based on the bounding box for the entire octree & the pattern of child traversal.  (If both PT_STORE_BOX and PT_CALC_BOX are 1, extra runtime debugging code is compiled in to verify that both methods produce c
ongruent results.)}{
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}PT_EVEN_DESCENT_TESTPROBE\line If set, TestProbe() is implemented by an algorithm (the \'93even-descent\'94
 approach) that decides, at each branch node, which children must be examined and in which order, before descending into the children. If not set, TestProbe() is implemented by an algorithm (the \'93stabbing\'94
 approach) that searches the tree each time, finding each child as the test-probe moves between leaf-cells.\line The stabbing TestProbe() would seem to be a bad idea; it relies on moving the cell-exit point forward along the test-probe by a \'93very small
\'94 amount, so that the next adjacent leaf-cell can be found. There are all sorts of tree constructions and test-probe situations that would cause it to generate incorrect results. However, the stabbing T
estProbe() is presently quite a bit faster than the even-descent TestProbe(). If that ever gets rectified, the stabbing TestProbe() can be removed, but not until then.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}PT_USE_CENTER_POINT\line If set, AddGeometry() will calculate an optimal location for each octree cell\rquote 
s center point. If the optimal location involves skipping a dimension or two (i.e. actually creating a quadtree node or bintree node instead of a full octree node), it will do so. This increases the size of an octree node from 4 bytes to 8 bytes, and}{
 potentially allows geometry to be divided up more efficiently, as the algorithm now tends to partition geometry instead of partitioning space.\line }{If not set, AddGeometry() always chooses a center point that\rquote 
s in the geographic center of the cell (and saves the associated storage costs).\line }{
The center-point is stored as 3 10-bit numbers, each describing the distance between the cell's minimum & maximum where the center point lies, in all dimensions.  (Allowed values range from 1 to 1023; a value of 0 means th
e cell isn't divided along that dimension, which allows for quadtree and bintree nodes to be mixed into the octree.)  \line }{The center point is chosen in a way very reminiscent of Quake II\rquote 
s q2bsp tool; it tries to divide the remaining polygons in half without splitting too many of them in half, and it tries to cut away space that contains no geometry.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}{PT_U}{SEVERTBOX\line If set, each cell contains a bounding box that tightly contains the geometry. This is used to reduce the number of polygon intersections that must be calculated.\line }{
If PT_USEVERTBOX is 1, the vertex-box is stored as 6 5-bit numbers that, like the center-point, describe lerps between the cell's minimum & maximum.  If PT_USEVERTBOX is 2, the vertex-box is stored as 2 Vector3 objects.}{
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}PT_RENUMBER\line If set, the octree data (which includes the geometry) is rearranged so that it fits better into data-cache lines in the PlayStation 2\rquote 
s two-way set-associative cache. In particular, this means that the memory is first packed into 64-byte parts, then the 64-byte parts are packed into blocks of 4096 bytes. The intent was to reduce data-cache thrashing, but so far the idea doesn\rquote 
t seem to be paying off.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}PT_INDEXED_CHILDREN\line If set, a separate ChildIndices array is used to contain the offsets to all of a cell\rquote s children. 
Also, the cells are allocated in an array too, instead of a tree.\line The idea is that the cell\rquote 
s Children pointer becomes a pointer into the ChildIndices array, where each index indicates an offset (positive or negative) from the current cell. This allows each cell to find its children without knowing where it is in the cell array.\line 
Also, the first child index is not really an index, but a bitfield indicating which children actually exist. This way, empty leaf nodes, and nodes belonging to missing center-point split planes, don\rquote t have to be stored, saving memory.\line 
This option saves quite a bit of memory, but its original intention was to allow the cells to be renumbered & thus packed more efficiently into memory. And since renumbering isn\rquote t working, and this option otherwise isn\rquote 
t giving us a speed increase, it remains off by default.
\par }\pard \ql \li360\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 {
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {The CellType interface
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phPolytree expects any CellType class to support a certain set of features:
\par 
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li720\ri0\widctlpar\jclisttab\tx720\aspalpha\aspnum\faauto\ls2\adjustright\rin0\lin720\itap0 {static const phBoundGeometry * smGeom\line 
The geometry being partitioned by AddGeometry().
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}static phBoundGeometry * smNewGeom\line The geometry that will receive the renumbered version of the tree.\line Only used if the renumbering feature is turned on.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}static PolyIndex * smTreePolys\line The polygon-reference array. GetFirstPoly() and GetNumPolys() (see below) provide an index into this array & a range.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}void WriteResource (rscResourceBase * rsc) const\line Write ourself to a resource file.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}void WriteCells (datAsciiTokenizer & token) const\line Write ourself to an asset file.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}int ReadCells (datAsciiTokenizer & token, int numRemainingCells)\line Read ourself from an asset file.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}int CountNumLevels () const\line Calculate the maximum tree depth.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}int CountNumPolys () const\line Calculate the number of polygon references. (Two different leaf nodes referring to the same polygon, counts as two references.)
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}int CountNumCells () const\line Calculate the total number of cells in the tree.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}int CountNumLeaves () const\line Calculate the total number of leaf cells in the tree.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}void CountNumIndexedChildren (int &a_riChildren, int &a_riChildIndices) const\line When the indexed-child feature is turned on, this method calculates the number of cells that\rquote 
ll end up in the indexed version of the tree, and the number of child-indices that\rquote ll be needed to construct the tree.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}float CalcMinCellSizeRecurse () const\line Finds the smallest extent of any cell in the tree, and returns it.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}int WhichChild (const Vector3 &a_rPoint, const Vector3 &a_rSlope, const Vector3 &a_rCenter) const\line 
When the even-descent-TestProbe() feature is turned on, this method determines which child-cell a given point is in.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}const CellType * FindCell (const Vector3 & point, const Vector3 & boxMin, const Vector3 & boxMax) const
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}const CellType * FindNextCell (const Vector3 & A, const Vector3 & AB, const Vector3 & B, float minCellSize, const Vector3 & boxMin, const Vector3 & boxMax) const\line 
When the even-descent-TestProbe() feature is turned }{\i off}{, these two methods control how leaf cells are traversed during test-probes.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}bool HasChildren () const\line Returns true if the cell has children (i.e. is a branch node).
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}bool IsLeafCell () const\line Returns true if the cell is a leaf (i.e. doesn\rquote t have children).
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}bool HasIndexedChildren () const\line If the indexed-children feature is turned on, this method returns true if the cell has indexed children.\line This method may assume that HasCh
ildren() was already checked & returned true.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}int GetFirstPoly () const / int GetNumPolys () const\line Only valid to call on leaf cells. Returns the index in smTreePolys that corresponds to this leaf cell\rquote 
s polygons, and the number of polygons in the leaf cell.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}void GetChildren (CellType *a_apChildren[])
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}void GetChildren (const CellType *a_apChildren[]) const\line Get all the children of this cell.\line This method may assume that HasChildren() was already checked & returned true.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}GetChild()\line Get one child of this cell.\line This method may assume that HasChildren() was already checked & returned true.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Vector3 GetCellCenter (const Vector3 &  a_rCellMin, const Vector3 &  a_rCellSize, const Vector3 &  a_rCellMax) const\line Returns the center of the cell. If the center-point feature i
s not turned on, this usually means the geographic center of the cell.
\par {\listtext\pard\plain\f3 \loch\af3\dbch\af0\hich\f3 \'b7\tab}void DrawCellsRecurse (const Matrix34 & cs) const\line If ENABLE_DRAW_PHYS is on, this method draws the tree. This is a debugging feature only.
\par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par As you can see, this list is a big convoluted mess. Clearly, we don\rquote t expect very many cell-type classes, and the ones we have will probably get cleaned up.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phQuadreeCell
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
phQuadtreeCell exists because some of our geometry (e.g. ground planes) are more efficiently partitioned by a quadtree. It\rquote s only 4 bytes long.
\par The data is either a pointer to the tree-node\rquote s children, or, for leaf nodes, the first polygon number & the number of polygons. (To disambiguate the two, the high bit is set in a leaf node & clear in a tree node. Since pointers with the high
 bit set are reserved for kernel addresses under most operating systems, this doesn\rquote t cause a problem.)
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phOctreeCell
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phOctreeCell is the most commonly used CellType. It\rquote 
s only 4 bytes long; with the center-point feature turned on, it\rquote s 8 bytes.
\par The first 4 bytes either contains a pointer to the tree-node\rquote 
s children, or, for leaf nodes, it contains the first polygon number & the number of polygons. (To disambiguate the two, the high bit is set in a leaf node & clear in a tree node. Since pointers with the hi
gh bit set are reserved for kernel addresses under most operating systems, this doesn\rquote t cause a problem.) When the indexed-cell feature is turned on, a child pointer with the low bit set means that it points within the phPolytree\rquote 
s ChildCellIndices array. (Since pointers to cells are aligned to at least 4-byte boundaries, this doesn\rquote t cause a problem.)
\par The next four bytes contain the center point. Note that the center point is stored with 3 10-bit numbers, each an offset between the cell\rquote s min and max. The idea is that having the cell\rquote 
s min and max stored separately gives us the flexibility to not repeat that information when specifying the center point, saving space. A value of 0 means there\rquote s no split-plane for that dimension; this allows an octree cell to
 represent a quadtree or bintree cell too.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Tree construction
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Presently, phBoundOctree controls turning a phBoundGeometry into an octree. But there\rquote 
s nothing to stop one from using phPolytree directly.
\par Call Configure() to set up the tree construction parame
ters. The number of polygons it asks for is really the number of polygon references you expect; there is one for every reference to a polygon in a leaf node. The maximum height limits how deep the tree can get; the maximum-polygons-per-cell controls the l
argest number of polygons that can be left in a leaf cell; any cells with more than that number of polygons is split. If you don\rquote t call Configure(), tree construction will use the default values.
\par Then call AddGeometry() to partition the geometry into an octree. AddGeometry()\rquote 
s actions depend heavily on what version of the octree was configured. All versions start by making a list of the polygons to be partitioned (using the octree scratchpad class). That\rquote s followed by calculating a bounding box for the octre
e; either it\rquote s a tightly-enclosing parallelopiped, or a loosely-enclosing cube, depending on the observed performance versus the possible compilation options.
\par If renumbering is turned on, AddGeometry() sets up a lot of arrays to hold the mapping from the original octree-bound data to the renumbered octree-bound data.
\par Then all versions call the CellType\rquote s AddGeometry() method, to do the vast majority of the work.
\par If indexed cells are turned on, the tree generated by CellType\rquote s AddGeometry() is converted to the indexed variant, using ConvertToIndexedCells().
\par If the even-descent TestProbe() is turned on, the maximum depth of the tree is calculated & stored. This allows the even-descent TestProbe() to preallocate all the space it needs at runtime in order to do its work.
\par If renumbering is turned on, the tree is finally renumbered, and the new version is produced. Then all the renumbering arrays are cleaned up.
\par Once the tree is constructed, it may be written out to disk. Use WriteCells() to write to an asset file, and WriteResource() to write to a resource file.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phOctreeCell\rquote s AddGeometry()
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
AddGeometry() is a recursive routine. It starts by tallying up how many polygons are in the current node; if the node has too many polygons, it gets subdivided. A center point i
s chosen for the cell; if the center-point feature is not turned on, the center is always the geographic center. The polygons are partitioned into each of the 8 children in turn, and AddGeometry() is called on each child.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {TestProbe()
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {There are two main variants of TestProbe(), the \'93stabbing\'94 version and the \'93even-descent\'94
 version. The even-descent version is intended to be the better one, but the stabbing version is presently performing better.
\par Both versions have to deal with the same design issue: a polygo
n may be in more than one leaf node. This means that, once a polygon intersection is found, an additional check must be made to ensure that the intersection happened within the current leaf node. If it didn\rquote t, there\rquote 
s a possibility that searching the next leaf node will find a closer polygon intersection. (If polygons were split across cell boundaries, rather than copied, this problem wouldn\rquote t exist, but then we\rquote d probably have other problems.)
\par The \'93stabbing\'94 TestProbe() begins by finding the leaf-node that contains the segment\rquote 
s start point. If the segment starts outside the tree, the point where it enters the tree is located, and then the tree is searched for the leaf-node that contains that entry point. Then the leaf-node is processed (i.e. polygon inters
ections are tested). The next leaf-node to check is found by finding the point where the segment leaves the cell, then moving a \'93very small\'94
 distance to get into the next cell, and then the tree is searched for the leaf-node that contains the slightly-moved exit point.
\par The \'93even descent\'94 TestProbe() starts by finding the first and last point on the probe that intersects the octree. That is, if the start point is in the octree, it\rquote s used, otherwise the point where the probe enters the octree is used, and if 
the end point is in the octree, it\rquote s used, otherwise the point where the probe exits the octree is used.
\par It keeps track of the probe\rquote s entry/exit from the cell using T values, i.e. values from 0 to 1 that indicate where along the probe the point is. As the
 traversal proceeds, fEntryT gets set to where the probe enters the current cell, and fExitT gets set to where the probe exits the current cell.
\par The even-descent TestProbe() is recursive by design, but rather than use real recursion, the maximum tree depth
 is calculated at tool time, and space for that many recursions is preallocated. Each stack frame keeps track of up to four children, the T value where the probe exits the parent of the four children, and the index of the next child to traverse. Each chil
d is a pointer to a CellType, the T value where the probe exits the child, and the child\rquote s bounding box. The root cell is placed on the \'93stack\'94, and then the recursion starts.
\par Leaf nodes are processed as before. Each tree node checks its children against th
e probe, to see which ones are intersected. (Up to four child nodes may be intersected; the one where the probe starts, and three more reached by crossing each center-aligned axial split plane.) The children are arranged in order according to nearest inte
rcept and put onto the stack. Intercepts are checked to see if they\rquote re in the current cell, by checking whether the intercept\rquote 
s T value is between fEntryT and fExitT; this is much faster than generating the point & checking it against the cell\rquote s bounding box.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Collision detection
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {I haven\rquote t taken this code apart yet.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phOctreeCell\rquote s PickCenter()
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
phOctreeCell::AddGeometry() will pick a center point before subdividing the current cell into children. How it does so, is a complex little project all by itself.
\par PickCenter() is largely inspired by Quake II\rquote 
s q2bsp tool. q2bsp creates a binary space partition from a constructive-solid-geometry based map file. On each iteration, it looks through all the planes of all the geometry inside the current tree node, and picks o
ne of the planes to subdivide that node. It heuristically ranks each plane according to a formula that tends to favor planes that splits the remaining geometry in half, without splitting too many polygons.
\par PickCenter() actually has three split planes to choose \endash 
 one for each dimension. It starts by finding the best split plane among all the choices in all the dimensions. It then tries to find the next best split plane, one that does a good job of dividing the two child cells we know about already. It then t
ries to find the last split plane, one that does a good job of dividing the four child cells we know about already. If it can\rquote t find a good first split plane, PickCenter() returns false to indicate it can\rquote t split the cell. If it can\rquote 
t find a good second or third split plane, PickCenter() returns true and ends up just creating a bintree or quadtree node, instead of a full octree node.
\par PickCenter() calls AnalyzeSplit() to perform the work of finding each split plane. AnalyzeSplit() relies on a helper class, phOctreeCellAnalyzer. phOctreeCellAnalyzer is a subclass of phSplitPlaneAnalyzer.
\par phSplitPlaneAnalyzer\rquote s purpose is to analyze a set of polygons that will be split by a plane oriented with a particular dimension. It does this by forming a list of polygon ex
tents, sorted by location & whether the value represents the beginning or end of a polygon\rquote 
s extent. phSplitPlaneAnalyzer maintains an internal tally of the number of polygons before & after the current split plane, and the number of polygons split by the 
current plane. As the plane moves, these numbers are adjusted. This data structure allows one to efficiently analyze every plane in the extent, factoring in the differences each time, instead of recalculating the whole picture for every query.
\par phOctreeCellAnalyzer is merely a subclass of phSplitPlaneAnalyzer that keeps track of the cell\rquote s bounding box. (phSplitPlaneAnalyzer has no need for the bounding boxes, but phOctreeCellAnalyzer\rquote 
s clients do. phOctreeCellAnalyzer exists to keep phSplitPlaneAnalyzer cleaner.)
\par AnalyzeSplit() tries every split-plane that\rquote 
s possible given the way we store the center point. (phSplitPlaneAnalyzer can handle any split plane locations, but only a few are available to phOctreeCell; AnalyzeSplit() is the one that limits the search to what\rquote 
s actually possible.) Instead of stepping through all possible center-point values, it narrows the range to that which would produce a minimum-sized cell or larger. Then, it starts the iteration one before that, i.e. with a value that would creat
e a smaller-than-minimum cell. The idea here is that the first & last split plane checked are actually invalid choices; if either one of them turns out to be the best split plane, then the real truth is that we can\rquote 
t find a good split plane. This heuristic helps to detect the natural termination of cell subdivision.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Extension
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Unresolved issues
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phBoundGeometry
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Many of the construction methods may not work. In particular, RemoveUnusedVerts() doesn\rquote 
t do anything, and RemoveDegeneratePolys() only removes polygons with non-unit normals. All phBoundGeometry methods still need to be vetted.
\par There are several load/save methods that look quite similar to each other. Are they all still being used? Can we get rid of some, or does the AGE team still have to maintain all of them?
\par ComputeEdges() does a linear search in order to determine if a particular edge has been seen before. This should at least be made a logarithmic search.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phPolytree
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phPolytree\rquote s center-point implementation (i.e. all the code turned on by defining
 PT_USE_CENTER_POINT to 1) allows phOctreeCell to implement quadtree and bintree cells as well as octree cells. It does this by allowing missing center-point dimensions. Once the center-point code is ready for prime time, phOctreeCell can implement quadtr
ees, and we can get rid of phQuadtreeCell.
\par phPolytree is partitioning the space behind visible geometry as well as the space in front of visible geometry.  Anything we do to partition space behind visible geometry is wasted work. It\rquote 
d take a much more sophisticated analysis to produce an octree like this, but it\rquote d be worth it. (Though it\rquote d probably be easier to do this by making it a BSP.)
\par phOctreeCell uses four bytes to describe the center point of a tree node. Those four bytes aren\rquote 
t used in leaf nodes. Find something to put there. One idea is to use that space to encode any contiguous range of polygons that are in the leaf cell, leaving the TreePolys array to hold the rest. That should save a lot of space inside TreePolys.
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phOctreeGrid
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phOctreeGrid should probably calculate its own optimal sizes for extents, using a method similar to phPolytree
\rquote s, i.e. look for cell sizes that tend to divide polygons into same-sized sets without splitting too many polygons in half.
\par }\pard\plain \s2\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \b\i\f1\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Future directions
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par }\pard\plain \s3\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f1\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {phPolytree
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
Since phPolytree is one of the biggest hot spots in our games, it will undoubtedly continue to be researched & developed, especially its performance.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Configurable versions
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Our various projects have 
different, incompatible needs. SWAT needs time performance, it doesn't care that much about space usage. MC2 of course likes time performance, but not if it chews up a lot of memory.  One near-future plan is to rearrange phPolytree and phBoundOctree so th
at each project can create their own version.  For example, imagine a header file like this:
\par 
\par }{\f2\fs20 #define PT_STORE_BOX 1
\par #define PT_CALC_BOX 0
\par #define PT_USEVERTBOX 2
\par #define PT_EVEN_DESCENT_TESTPROBE 0
\par #define PT_USE_CENTER_POINT 1
\par #define PT_RENUMBER 0
\par #define PT_INDEXED_CHILDREN 0
\par 
\par #define phPolytree swatOctree
\par #include "phbound/polytree.h"
\par 
\par #undef phPolytree
\par #undef PT_INDEXED_CHILDREN
\par #undef PT_RENUMBER
\par #undef PT_USE_CENTER_POINT
\par #undef PT_EVEN_DESCENT_TESTPROBE
\par #undef PT_USEVERTBOX
\par #undef PT_CALC_BOX
\par #undef PT_STORE_BOX
\par }{
\par This example shows how SWAT can configure the new octree so that it closely matches the implementation of the old octree.  phBoundOctree would become a templated class, so that one can specify the version of phPolytree to use with it.  A pro
ject could presumably use several different variants of the octree, depending on performance requirements, and give them different names.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Reducing memory thrashing
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {We're pretty sure that memory access is a bottleneck on the PS2, though I've had a heck of a
 time trying to find effective ways to fix it.  (For instance, I'm }{\i really}{ surprised that PT_RENUMBER hardly bought us anything.)
\par One way to reduce phPolytree's memory thrashing is to batch testprobes, i.e. the client code hands phPolytree a big list of pro
bes to do, and phPolytree hands back a bit list of results.  Recoding phPolytree's even-descent code to manage several simultaneous probes isn't that hard; the stabbing-testprobe code isn't really amenable to being rewritten to better support batched prob
es, but we can try using it anyway.
\par This is a big architecture change for our games, though, and so we probably shouldn't go ahead with this unless we're pretty sure it's going to pay off.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {More PS2 assembly
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {One relatively easy way to increase test-probe per
formance on the PS2 is to rewrite large sections of phPolytree and phOctreeCell as PS2 assembly.  phOctreeCell::TestProbe() is one of the hottest of the hot spots in our games; that routine, and everything it calls, can easily be converted to a single blo
ck of PS2 vector math.
\par }\pard\plain \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Binary space partitioning
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
phPolytree presently supports octree nodes; with PT_USE_CENTER_POINT==1, it can support quadtree and bintree nodes too, all mixed into the same tree.  To this, I propose adding a BSP node.  Most of my experie
nce with BSPs came from Quake II; there, all the split planes were taken from the planes of polygons.  Our BSP node can do this too; we can fit 2 polygon indices into 32 bits, giving our BSP nodes 4 children.  (If the two polygon indices are equal, we can
 
consider that a 1-plane BSP node with only 2 children.)  The idea is that we can use octree/quadtree/bintree cells to do most of the rough work of partitioning the geometry, and we can use BSP nodes to perform the final work near the leaf nodes.  The reas
o
n BSP nodes are superior to octree nodes is that the separating planes are taken from the polygons in the area; therefore, the BSP nodes completely describe what parts are solid, removing the need for a separate polygon-intersection step.  In other words,
 
once the BSP node has detected an intersection with something solid, it already knows (from tree construction) which polygon was hit, and so no succeeding polygon-intersection test is needed.  In my latest MC2 test, polygon intersection was a good 30% of 
the total octree-testprobe time, so this is not an insignificant potential savings.
\par }}